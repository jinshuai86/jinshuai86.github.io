<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.ico?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.ico?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="java.util.Map框架： HashMap12public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable  预备知识 红黑树是一种特殊的二叉查找树，由平衡二叉查找树进化而来(在AVL中，保持全树的平衡开销太大)，红黑树只">
<meta name="keywords" content="Java,JCF">
<meta property="og:type" content="article">
<meta property="og:title" content="Java容器框架源码阅读笔记（四）Map">
<meta property="og:url" content="https://github.jinshuai86.io/2018/07/23/Map/index.html">
<meta property="og:site_name" content="JinShuai&#39;s Blog">
<meta property="og:description" content="java.util.Map框架： HashMap12public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable  预备知识 红黑树是一种特殊的二叉查找树，由平衡二叉查找树进化而来(在AVL中，保持全树的平衡开销太大)，红黑树只">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://github.jinshuai86.io/img/in-post/post-java-collection/Map.svg">
<meta property="og:image" content="https://github.jinshuai86.io/img/in-post/post-java-collection/Red-black_tree.png">
<meta property="og:updated_time" content="2022-06-11T10:26:46.661Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java容器框架源码阅读笔记（四）Map">
<meta name="twitter:description" content="java.util.Map框架： HashMap12public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable  预备知识 红黑树是一种特殊的二叉查找树，由平衡二叉查找树进化而来(在AVL中，保持全树的平衡开销太大)，红黑树只">
<meta name="twitter:image" content="https://github.jinshuai86.io/img/in-post/post-java-collection/Map.svg">



  <link rel="alternate" href="/atom.xml" title="JinShuai's Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://github.jinshuai86.io/2018/07/23/Map/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java容器框架源码阅读笔记（四）Map | JinShuai's Blog</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5b329c61c506f4e345e399b929faf77f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JinShuai's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">稳住别慌，问题不大</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-wiki">

    
    
    
      
    

    
      
    

    <a href="https://jinshuai86.github.io/wiki" rel="noopener" target="_blank"><i class="menu-item-icon fa fa-fw fa-book"></i> <br>Wiki</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives<span class="badge">19</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories<span class="badge">4</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags<span class="badge">8</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/jinshuai86" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.jinshuai86.io/2018/07/23/Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Shuai">
      <meta itemprop="description" content="万丈高楼平地起，勿在浮沙筑高塔">
      <meta itemprop="image" content="/img/avatar-js.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JinShuai's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java容器框架源码阅读笔记（四）Map

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              

              
                
              

              <time title="Created: 2018-07-23 00:00:00" itemprop="dateCreated datePublished" datetime="2018-07-23T00:00:00+08:00">2018-07-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon" title="Views">
            <i class="fa fa-eye"></i>
            
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>java.util.Map</code>框架：<br><img src="/img/in-post/post-java-collection/Map.svg" alt="Map接口"></p>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul>
<li>红黑树是一种特殊的二叉查找树，由平衡二叉查找树进化而来(在AVL中，保持全树的平衡开销太大)，红黑树只是保持局部平衡，即从每个节点向下直到叶子节点的路径中包含的黑色节点数量相同，达到一种”弱平衡”。它可以在 <strong>logn</strong> 时间内做查找，插入和删除，n是树中节点的数目。特性:  <ul>
<li><strong>根</strong>节点是黑色</li>
<li>从<strong>任一节点</strong>到其每个<strong>叶子节点</strong>的所有简单路径都包含相同数目的<strong>黑色节点</strong></li>
<li>叶子节点是不放数据的<strong>黑色节点</strong></li>
<li><strong>红色节点</strong>不能连续(红色节点的孩子和父亲节点颜色都不能是红色)</li>
</ul>
</li>
</ul>
<p><img src="/img/in-post/post-java-collection/Red-black_tree.png" alt="红黑树wiki"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol>
<li>继承自<code>AbstractMap</code>，实现了<code>Cloneable</code>接口但是是<strong>浅</strong>拷贝，实现了<code>Seriable</code>可以进行序列化，实现了<code>Map</code>。  </li>
<li>基于数组(<code>Node</code>) + 链表(<code>Node</code>) + 红黑树(<code>TreeNode</code>)实现，当链表长度达到8时，链表会变为红黑树。在<code>resize()</code>对红黑树进行切割<code>split()</code>时，如果切割后的红黑树大小减少到6就变回链表。</li>
<li>非线程安全，如果需要线程安全需要使用<code>ConcurrentHashMap</code>、<code>Collections.synchronizedMap(new HashMap())</code>、<del><code>HashTable</code></del></li>
<li>可以存一个null key，数组下标默认是0，之后的null key会覆盖原来的。</li>
<li>数据不保证有序（放进去的顺序和拿出来的顺序不一样），如果需要有序可以使用<code>TreeMap</code>、<code>LinkedHashMap</code></li>
<li>数组长度是<strong>2的幂</strong>,初始是16,最大值是32。</li>
<li>数组长度是2的幂,这样可以通过位操作(&amp;)代替%提高计算效率，数组.length – 1 使得低位数字全为1 使得 &amp; 数组.length – 1得到的分布比不是2的幂的情况要均匀。  </li>
<li>通过用key的<code>hashcode()</code>再次求hash然后通过位运算得出要存的数组下标。</li>
<li>默认加载因子是0.75,当数组中元素的数量<strong>超过</strong>数组长度的0.75倍会进行扩容。</li>
<li>通过拉链法解决hash冲突，除此之外解决hash冲突的方法还有<strong>开放地址法(再散列法)、再哈希法、建立公共溢出区</strong>。</li>
</ol>
<h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量/常量"></a>变量/常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组默认容量，2^4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组最大容量 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认负载因子，如果没指定负载因子，就会用这个默认的。通过负载因子来确定阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表树化阈值，当链表长度达到8就会变为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树链化阈值，在resize()时，会对红黑树进行分割split(),如果分割后的红黑树元素个数减少到6就会变为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在变红黑树时，还会判断数组的【长度】是否大于64，如果小于64则直接进行扩容resize()，不会变为红黑树。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出的阈值，当键值对的数量大于该阈值后，就会进行resize()扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以接收指定的负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据key获取value   </span></span><br><span class="line"><span class="comment"> * */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 基本思路:  </span></span><br><span class="line"><span class="comment"> * 根据提前计算好的hash =&gt;   </span></span><br><span class="line"><span class="comment"> * 计算数组下标(hash &amp; (tab.length - 1)) =&gt;   </span></span><br><span class="line"><span class="comment"> * 判断下标元素是否是查找的节点 =&gt;   </span></span><br><span class="line"><span class="comment"> *    是：直接返回节点  </span></span><br><span class="line"><span class="comment"> *    不是:继续在红黑树 || 单链表中查找  </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 预判断:数组是否为null，数组长度是否为0，求出的下标对应的元素是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 求出的下标对应的数组元素就是要获取的目标节点(如果两个key相同，那么hash肯定相同，所在先比较的hash。再就是先判断两个key是否指向同一个对象，如果指向同一个对象，就不用再执行耗时的equals操作)</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 求出的下标对应的数组元素不是要获取的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 从红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 从单链表中查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 将key，value插入到HashMap中</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 基本思路:  </span></span><br><span class="line"><span class="comment"> * 根据提前计算的hash =&gt;  </span></span><br><span class="line"><span class="comment"> * 计算要插入的数组下标(hash &amp; (tab.length - 1)) =&gt;  </span></span><br><span class="line"><span class="comment"> * 根据是链表还是红黑树插入目标节点  </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    <span class="comment">// 指向数组下标为 "hash与数组长度取模后((n - 1) &amp; hash)" 的元素</span></span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="comment">// n是数组长度，i是元素要插入的下标((n - 1) &amp; hash)</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果数组为null，代表数组还没有初始化。需要执行resize()初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果求出的数组下标对应的元素为null，代表该下标还没有元素，则直接在该下标添加元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果求出的数组下标已经存在元素，判断是红黑树还是链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到HashMap中该key对应的元素，然后让e指向该元素。当然也可能不存在该key对应的元素，从而找不到，使得e为null。  </span></span><br><span class="line">        <span class="comment">// 后续通过判断e是否为null来决定此次put是更新操作还是插入操作。  </span></span><br><span class="line">        <span class="comment">// 如果e为null，说明HashMap中并不存在key对应的元素，直接执行的插入操作  </span></span><br><span class="line">        <span class="comment">// 如果e不为null，说明HashMap中存在该key对应的元素，并且让e指向了该元素，需要执行更新操作，更新key对应元素的value。  </span></span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 如果是求出的数组下标的元素key和hash与新传进来的key和hash相同(传过来的key已经存在于数组中)</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 注意此时并没有更新节点值，只是将e指向该节点(此时e不为null)，最后会判断e是否为null，决定是否更新。</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果数组元素类型是红黑树 =&gt; 将新节点插入/更新到红黑树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组元素是单链表，进行尾插</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到表尾</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 插入元素后，如果当前链表长度 &gt; 7 则调用treefyBin() "决定是否" 变红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 因为binCount 从0开始，当binCount等于7时，代表链表长度为8。</span></span><br><span class="line">                        <span class="comment">// 将链表改为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 尾插过程中，如果已经存在此key，将e指向此key，退出。后面进行更新旧值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是已经存在的key，上面的遍历过程只是找到key对应的节点，并没有更新值</span></span><br><span class="line">        <span class="comment">// 最后需要更新节点旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录修改次数，fail-fast机制要用到</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果元素(键值对)数量大于阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// LinkedHashMap通过重写它，执行后续的操作：将这个节点添加到双向链表尾部。</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 还会进一步判断数组长度是否小于MIN_TREEIFY_CAPACITY，来决定是否变红黑树</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果数组长度比较小就直接扩容（小于变红黑树的阈值），不用变成红黑树。</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 将该位置对应的链表变为红黑树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="public-V-remove-Object-key"><a href="#public-V-remove-Object-key" class="headerlink" title="public V remove(Object key)"></a>public V remove(Object key)</h3><p>删除key对应的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向原数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 指向求出的数组下标对应的元素</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="comment">// n为数组长度，index为通过key求出的下标</span></span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 判断边界条件：数组是否为null、数组长度是否为0、下标对应的元素是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// node最终指向要删除的节点</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; </span><br><span class="line">        K k; V v;</span><br><span class="line">        <span class="comment">// 判断下标对应的元素是否就是要删除的元素，如果是，直接将node指向这个元素</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 如果不是的话，要删除的元素可能在红黑树里或者在单链表中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果在数组下标元素类型是红黑树节点类型就在红黑树中查找欲删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果数组下标元素类型是单链表节点类型就在链表中查找欲删除的节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除node指向的节点(因为执行了上面的代码，如果欲删除的元素在map中，此时node已经指向欲删除的元素)</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果要删除的节点类型是红黑树，就执行红黑树删除节点的api</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果要删除的节点类型是单链表，就执行单链表删除节点操作，下面的p此时是node的前置节点(因为在遍历单链表时，p一直在node前面)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 添加修改次数</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 键值对数量减1</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 执行完删除节点操作以后，会执行LinkedHashMap重写的这个方法(实际上就是执行双向链表的删除节点的操作，因为LinkedHashMap里的是双向链表)</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">// 返回删除的节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 2倍扩容数组长度  </span></span><br><span class="line"><span class="comment"> * */</span>  </span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果当前数组存在元素：不是新创建的</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前数组长度大于等于允许的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 阈值就变成无穷大</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前数组长度没有超过最大长度，二倍扩容数组长度和阈值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过HashMap(int initialCapacity, float loadFactor) 或者 HashMap(int initialCapacity) 【新】创建的HashMap对象</span></span><br><span class="line">    <span class="comment">// 新创建的HashMap对象的阈值threshold的值是通过初始长度initialCapacity生成的一个2的幂。</span></span><br><span class="line">    <span class="comment">// 然后将阈值赋给newCap的目的是保证最终创建的数组长度是2的幂。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 新创建的：直接调用的无参构造函数</span></span><br><span class="line">    <span class="comment">// 数组长度和加载因子/阈值直接使用默认生成的。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对 " else if (oldThr &gt; 0) " 求阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 判断要设置数组长度是否超过了允许的最大容量，来决定阈值的值是现在的值((float)newCap * loadFactor)还是Integer.MAX_VALUE</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 生成一个二倍长度的新数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果是旧数组 =&gt; 直接拷贝元素到新数组</span></span><br><span class="line">    <span class="comment">// 元素在旧数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果只有一个元素（只有一个单链表的头节点或者只有一个红黑树的根节点）</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果不只一个元素，并且元素类型是TreeNode</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 如果不只一个元素，并且是单链表 =&gt; 遍历单链表</span></span><br><span class="line">                <span class="comment">// 保留整个单链表的顺序，然后整体移动到newTab[X ，X如下↓]后面</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 运算结果为0的元素，用loHead记录并连接成新的链表</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 运算结果不为0的元素，用hiHead记录并连接成新的链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 参考Q&amp;A</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li>JDK8在<code>resize()</code>中，将原先的链表通过<code>if((e.hash &amp; oldCap) == 0)</code>分割成两个子链表，这两个子链表在新数组中的下标为什么是<code>j</code>和<code>j + oldCap</code>？这样在新数组中通过<code>hash &amp; newTab.length - 1</code>能对应上？<ul>
<li>对于<code>(e.hash &amp; oldCap) == 0</code>的元素(<strong>后面的分析都是基于这个前提</strong>) =&gt; 在原数组中的下标<strong>等于</strong>要转移到新数组中的下标。原因：<ul>
<li><code>(e.hash &amp; oldCap) == 0?</code>就是判断<code>oldCap</code>高位对应的<code>hash</code>位是否为0。未扩容之前,<code>hash</code>只和<code>oldCap - 1</code><strong>低位</strong>做<code>&amp;</code>运算来求在原始数组中的下标,扩容之后本质上还是和<code>oldCap - 1</code><strong>低位</strong>做<code>&amp;</code>运算来求在新数组中的下标。</li>
<li>二倍扩容后，新数组的长度<code>newCap</code>为<code>oldCap &lt;&lt; 1</code>，之后求元素在新数组中的下标<code>(hash &amp; (newCap - 1))</code>。因为 <code>newCap - 1</code>高位为0,与此同时高位后一个位(也就是<code>oldCap</code>高位)对应的<code>hash</code>位也为0,所以<code>(hash &amp; (newCap - 1))</code>等价于<code>(hash &amp; (oldCap - 1))</code>。举个例子：  </li>
</ul>
</li>
</ul>
</li>
</ol>
<p>假设<code>oldCap</code>值是<code>2^4 = 16</code>,某个元素e的<code>hash</code>是<code>0111 0101</code>。这个元素在原始数组中的下标应该是<code>hash &amp; oldCap - 1</code> = 5。此时<code>(e.hash &amp; oldCap) == 0</code>,根据结论：如果扩容以后，元素e所在新数组的下标应该还是<code>hash &amp; oldCap - 1</code> = 5。 事实是这样：<code>hash &amp; newCap - 1</code> = 5。</p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">二进制值</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">oldCap</td>
<td align="center">0000 1000</td>
<td align="center">因为是2的幂所以高位为1,低位全为0。</td>
</tr>
<tr>
<td align="center">hash</td>
<td align="center">0111 0101</td>
<td align="center">随意选的</td>
</tr>
<tr>
<td align="center">oldCap - 1</td>
<td align="center">0000 0111</td>
<td align="center">oldCap - 1的高位为0,低位全为1</td>
</tr>
<tr>
<td align="center">newCap</td>
<td align="center">0001 0000</td>
<td align="center">等于<code>2*oldCap</code>，将oldCap左移一位即可</td>
</tr>
</tbody></table>
<p>此时<code>hash &amp; oldCap</code> = 0推出<code>oldCap</code><strong>高位</strong>对应的<code>hash</code>位<strong>一定</strong>为0。否则求出的值绝对不是0。<br>如下图：当通过<code>hash &amp; (newCap - 1)</code>求元素e在新数组中的下标，实际是和最后三位进行<code>&amp;</code>运算，计算结果和<code>hash &amp; (oldCap - 1)</code>一样  </p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">二进制值</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hash</td>
<td align="center">0111 0101</td>
<td align="center">oldCap高位对应的hash位<strong>为0</strong></td>
</tr>
<tr>
<td align="center">newCap -1</td>
<td align="center">0000 1111</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">oldCap - 1</td>
<td align="center">0000 0111</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>对于<code>(e.hash &amp; oldCap) != 0</code>的元素(<strong>后面的分析都是基于这个前提</strong>) =&gt; 扩容后元素e在新数组中的下标<strong>等于</strong>元素e在原数组中的下标+原数组长度。 原因：（新数组下标计算过程）<ul>
<li>新数组下标<ul>
<li>hash &amp; (newCap - 1)👇</li>
<li>hash &amp; (2 * oldCap - 1)👇</li>
<li>hash &amp; (oldCap + oldCap -1)👇</li>
<li>(hash &amp; oldCap - hash &amp; 1) + hash &amp; oldCap👇<ul>
<li>由<code>(e.hash &amp; oldCap) != 0</code>可以推出<code>oldCap</code>高位对应的<code>hash</code>位不为0可以推出<code>hash &amp; oldCap == oldCap</code></li>
</ul>
</li>
<li>hash &amp; (oldCap - 1) + oldCap👇</li>
</ul>
</li>
<li>原数组下标 + 原数组长度数组</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">二进制值</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hash</td>
<td align="center">0111 1101</td>
<td align="center">oldCap高位对应的hash位<strong>不为0</strong></td>
</tr>
<tr>
<td align="center">newCap -1</td>
<td align="center">0000 1111</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">oldCap - 1</td>
<td align="center">0000 0111</td>
<td align="center"></td>
</tr>
</tbody></table>
<ol start="2">
<li><p>为什么长度为6时用链表，为8时用红黑树？中间的7是干嘛的？</p>
<ul>
<li>因为红黑树查找时间复杂度为O(LogN)，链表查找时间复杂度为O(N)，当链表中节点数量较多时，为了提高查找效率会采用红黑树。又因为红黑树的节点大约是链表节点的两倍，所以为了节省空间，链表转红黑树的阈值不能太小。</li>
<li>对于分布均匀的hash函数来说，桶中冲突元素的数量服从泊松分布，冲突元素数量是8的概率为千万分之一，是一个小概率事件，如果这个小概率事件发生了，说明冲突比较严重，这时就会将链表转为红黑树提高查询效率。</li>
</ul>
<blockquote>
<p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  </p>
</blockquote>
<ul>
<li>中间隔一个7为了防止链表和红黑树频繁转换影响效率。如果不隔7的话，元素个数频繁从6变到7或者从8变到7，会造成红黑树和链表频繁的进行转换。(<strong>个人理解</strong>)</li>
</ul>
</li>
<li><p>为什么不是线程安全的?具体体现在哪儿?</p>
<ul>
<li><ol>
<li>在多线程的情况下，并发执行<code>resize()</code>可能会产生环形链表，从而在<code>get()</code>时可能差生inflate loop。</li>
</ol>
</li>
<li><ol start="2">
<li>比如并发插入元素时，会并发修改size。</li>
</ol>
</li>
</ul>
</li>
<li><p>为什么产生环形链表？</p>
<ul>
<li><p>主要是由于转移链表时在新数组中的顺序和原数组顺序不一致导致的。</p>
<ul>
<li><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：JAVA HASHMAP的死循环</a></li>
<li><a href="http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html" target="_blank" rel="noopener">A Beautiful Race Condition(需要科学上网)</a></li>
</ul>
</li>
</ul>
</li>
<li><p>为什么求出hashCode()之后要二次hash？</p>
<ul>
<li>二次hash为了使得哈希码低位元素更加具有随机性。</li>
</ul>
</li>
<li><p>为什么数组长度是2的幂？</p>
<ul>
<li>可以通过位操作<code>&amp;</code>代替<code>%</code>进行取模运算提高效率。</li>
<li>可以使得求出的数组下标充分依赖hash码，因为2的幂 - 1保证了低位全为1，做&amp;运算可以完全依赖hash，而hash已经通过二次hash随机性很强，从而使得分布会相对均匀。</li>
</ul>
</li>
<li><p>为什么加载因子loadFactor默认是0.75？</p>
<ul>
<li>加载因子太大：空间利用率高，查询效率变低，容易发生冲突。  </li>
<li>加载因子太小：不容易产生冲突，查询效率高，空间利用率低，频繁扩容会产生性能影响  <blockquote>
<p>As a general rule, <strong>the default load factor (.75) offers a good tradeoff between time and space costs.</strong>  Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in<br>the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations.  If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.  </p>
</blockquote>
</li>
</ul>
</li>
<li><p>JDK8和JDK7关于HashMap的区别?  </p>
<ul>
<li>JDK7基于数组加链表实现，JDK8引入了红黑树解决了发生hash冲突后，链表过长导致查询效率变低的问题。</li>
<li>JDK7采用单链表头插法解决hash冲突，JDK8采用尾插法  </li>
<li>JDK8 resize()后的链表中元素的相对顺序不变。不会产生环形链表（<strong>个人看法，没证明</strong>）</li>
<li>JDK7数组类型是Entry类型，JDK8改为Node类型都是实现的Map.Entry接口。只是改了个名字</li>
</ul>
</li>
<li><p>HashMap和HashTable的区别？</p>
<ul>
<li>HashMap相对于HashTable可以存nul key 和 null value。 HashTable相对于HashMap是线程安全的。<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" target="_blank" rel="noopener">The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>为什么key一般用不变对象，比如String、Integer？</p>
<ul>
<li>如果对象可变，比如User对象的name属性变了则计算出来的hash会变化，导致求出的数组下标会变从而找不到之前User对应的value。建议key尽量是String或者Integer，不应该是可变的对象。 </li>
</ul>
</li>
<li><p>解决hash冲突的方法？</p>
</li>
</ol>
<ul>
<li>开放地址法(再散列法)  <ul>
<li>线性探测：如果冲突了以后，继续向后查找直到找到一个空位</li>
<li>二次探测：相对于线性探测，它是两步两步的跳着找空位，比较灵活</li>
</ul>
</li>
</ul>
<blockquote>
<p>开放地址法适合存放较少数量的键值对，比如<code>Thread</code>中维护的<code>ThreadLocalMap</code>就是用的开放地址法解决的哈希冲突，因为一般通过<code>ThreadLocal</code>设置的键值对数量比较少。如果存放的数量过多，最坏的时间复杂度可能会达到O(n)</p>
</blockquote>
<ul>
<li>链地址法：将冲突的元素，构造成一个单链表</li>
<li>再哈希法：提前构造多个hash函数，如果某个hash函数冲突以后，再换别的hash函数，直到找到不冲突的为止</li>
<li>建立公共溢出区：将冲突的元素放到溢出区中，和不冲突的元素分开。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/carson_ho/article/details/79373026" target="_blank" rel="noopener">Java：手把手带你源码分析 HashMap 1.7</a></li>
<li><a href="https://stackoverflow.com/questions/35534906/java-hashmap-getobject-infinite-loop" target="_blank" rel="noopener">Java HashMap.get(Object) infinite loop</a></li>
<li><a href="http://blog.jrwang.me/2016/java-collections-hashmap/" target="_blank" rel="noopener">Java 容器源码分析之 HashMap</a></li>
</ul>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p><code>LinkedHashMap</code>继承自<code>HashMap</code>，在此基础上，将所有<strong>键值对</strong>用双向链表链了起来，这样可以实现元素的迭代顺序和元素的插入顺序一致。在HashMap基础上加了钩子函数，可以实现元素的迭代顺序和元素的访问顺序一致(访问一个元素以后就会将元素放到双链表的尾部)，通过这个特性可以实现LRU cache</p>
</li>
<li><p><code>LinkedHashMap</code>不是线程安全的，如果需要线程安全需要使用<code>Collections.synchronizedMap(new LinkedHashMap())</code></p>
</li>
<li><p><code>LinkedHashMap</code>继承了<code>HashMap</code>，用到了模板模式。一般的<code>get</code>、<code>put</code>、<code>remove</code>、都用到了<code>HashMap</code>中的操作</p>
</li>
</ul>
<h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表头指针，在LRU中可以理解为最【老】的节点(如果缓存不够最先剔除的节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表尾指针，在LRU中可以理解为最【新】的节点(如果缓存不够最先剔除的节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是true遍历时按访问顺序，false遍历时按插入顺序。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<h3 id="void-afterNodeInsertion-boolean-evict"><a href="#void-afterNodeInsertion-boolean-evict" class="headerlink" title="void afterNodeInsertion(boolean evict)"></a>void afterNodeInsertion(boolean evict)</h3><p>插入元素e后会根据<code>removeEldestEntry(first)</code>这个方法设定的阈值来决定是否要移除最老的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当向map中插入元素后执行的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        <span class="comment">// 执行HashMap中的删除节点api。 first=head就是最老的节点。(看###变量注释👆)</span></span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认直接返回true，可以定制 return size() &gt; 123; 当键值对的数量大于123时就会删除最老的元素。方便实现LRU cache</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="public-V-get-Object-key"><a href="#public-V-get-Object-key" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h3><p>访问元素e后，如果提前设置了<code>accessOrder</code>为<code>true</code>，就会调用afterNodeAccess(Node&lt;K,V&gt; e)将元素e放到链表的末尾(tail),来实现LRU Cache。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    <span class="comment">// 指向每一个</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 如果设置的访问顺序，也就是accessOrder为true并且链表最后一个节点不是e。就将刚才访问的e这个节点放到最后面</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将节点e的前后节点拼接起来，然后移除e，将e放到链表尾部。</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 链表尾指针为空(这是放的第一个元素)，就让head指针指向节点e</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="comment">// 将这个节点放到链表的尾部</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将双向链表尾指针指向e(将e放到双向链表最后面)</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">// 修改次数+1</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeRemoval-Node-lt-K-V-gt-e"><a href="#afterNodeRemoval-Node-lt-K-V-gt-e" class="headerlink" title="afterNodeRemoval(Node&lt;K,V&gt; e)"></a>afterNodeRemoval(Node&lt;K,V&gt; e)</h3><p>当执行<code>HashMap</code>中的<code>remove(Object key)</code>删除节点<code>key</code>对应的元素e后，会执行双向链表中删除节点的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// p是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="comment">// p不是头节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// p是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="comment">// p不是尾节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol>
<li>实现一个LRU Cache？  <ul>
<li>设置<code>accessOrder</code>为true，保证最近访问过的元素是最新元素</li>
<li>重写<code>removeEldestEntry(Map.Entry eldest)</code>设置一个缓存大小</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(CACHE_SIZE,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; lru = <span class="keyword">new</span> LRUCache();</span><br><span class="line">        lru.put(<span class="number">1</span>,<span class="string">"a"</span>);</span><br><span class="line">        lru.put(<span class="number">2</span>,<span class="string">"b"</span>);</span><br><span class="line">        lru.put(<span class="number">3</span>,<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">// 因为是从双向链表头部开始遍历到尾部，结果应该是 [1,2,3]，</span></span><br><span class="line">        System.out.println(lru.keySet());</span><br><span class="line">        lru.get(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 因为访问了2，所以会将2放到尾部，从双向链表头开始遍历到尾部，结果应该是[1,3,2]</span></span><br><span class="line">        System.out.println(lru.keySet());</span><br><span class="line">        lru.put(<span class="number">4</span>,<span class="string">"d"</span>);</span><br><span class="line">        <span class="comment">// 因为缓存容量设置的是3，所以添加4时 由于缓存已经满了，所以需要删除最老的，就是双向链表头部 1，最后结果应该是[3,2,4]</span></span><br><span class="line">        System.out.println(lru.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="预备知识-1"><a href="#预备知识-1" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h3><p>不同的引用类型体现了对垃圾回收的影响，并且可以在一定程度上允许我们<strong>干涉自动垃圾回收器</strong>。在Java中主要有四种引用类型：  </p>
<h4 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用(StrongReference)"></a>强引用(StrongReference)</h4><p>强引用是通过赋值运算符<code>=</code>将所引用的对象<code>obj</code>关联起来。比如<code>Object obj = new Object()</code>。如果一个对象的强引用还在，该对象就不会被JVM回收。</p>
<h4 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h4><p>软引用通过<code>SoftReference</code>将所引用的对象<code>obj</code>👆关联起来。比如<code>SoftReference sr = new SoftReference(obj)</code>。在内存不足要发生内存溢出OOM之前，会被JVM回收。</p>
<ul>
<li>如果<code>SoftReference</code>注册了引用队列<code>ReferenceQueue</code>，当回收软引用关联的对象<strong>之后</strong>，会将该软引用加入到<code>ReferenceQueue</code>。</li>
<li>和软引用关联的对象有用但不是必需的，所以软引用可以做缓存。当JVM内存不足时，会将这部分缓存回收掉。比如用户打开了多个图片，就需要加载多个图片内容到内存中，每个图片内容(字节数组)可以和软引用关联当作缓存，如果内存不足时就会清除内存中缓存的图片内容(字节数组)。不过要<strong>注意:</strong>当要再次查看图片时每次都要判断图片内容是否已经被回收(判断引用队列中是否有引用了)，如果被回收需要重新加载到内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个Image相当于一个图片，如果打开多个图片等价于创建多个Image对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图片路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">// 通过字节数组存放图片内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="comment">// 要和Image对象关联的软引用</span></span><br><span class="line">    <span class="keyword">private</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference;</span><br><span class="line">    <span class="comment">// 构造图片</span></span><br><span class="line">    Image(String path) &#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="comment">// 将图片加载进来</span></span><br><span class="line">        data = readImageByPath(path);</span><br><span class="line">        softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readImageByPath(String path) &#123;</span><br><span class="line">        <span class="comment">// 为了方便，没有具体实现,一次1MB_</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] dataArray = softReference.get();</span><br><span class="line">        <span class="comment">// 判断data是否已经被回收了，如果被回收了需要重新读取图片内容到内存中</span></span><br><span class="line">        <span class="keyword">if</span> (dataArray == <span class="keyword">null</span> || dataArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">            dataArray = readImageByPath(path);</span><br><span class="line">            softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(dataArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同时打开100张图片</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            Image image = <span class="keyword">new</span> Image(i + <span class="string">".jpg"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h4><ul>
<li>弱引用通过<code>WeakReference</code>将所引用的对象<code>obj</code>关联起来。比如<code>WeakReference sr = new WeakReference(obj)</code>,和弱引用关联的对象在垃圾回收时，会被JVM回收。<ul>
<li>如果<code>WeakReference</code>注册了引用队列<code>ReferenceQueue</code>，当回收弱引用关联的对象<strong>之后</strong>，会将该弱引用加入到<code>ReferenceQueue</code>。</li>
<li>和弱引用关联的对象不是必需的，弱引用多用在哈希表中，比如WeakHashMap通过<code>WeakReference</code>可以回收每一个被回收的key对象所关联的Entry(详细见下面源码分析👇)</li>
</ul>
</li>
</ul>
<blockquote>
<p>软引用、弱引用基本上没有本质上的区别，仅仅是软引用对象比弱引用对象的命更长一些罢了。<strong>(<a href="https://www.zfl9.com/java-ref.html" target="_blank" rel="noopener">参考链接</a>)</strong><br>因此，软引用、弱引用都适合用来实现内存敏感的高速缓存，具体使用哪种引用，这里给几条参考：<br>1) 如果只是想避免 OutOfMemory 的发生，则可以使用软引用；如果对于性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。<br>2) 如果对象可能会经常使用的，就尽量用软引用；如果对象不被使用的可能性更大些，就可以用弱引用。  </p>
</blockquote>
<h4 id="幽灵引用-PhantomReference"><a href="#幽灵引用-PhantomReference" class="headerlink" title="幽灵引用(PhantomReference)"></a>幽灵引用(PhantomReference)</h4><ul>
<li>幽灵引用通过<code>PhantomReference</code>将所引用的对象<code>obj</code>关联起来。比如<code>PhantomReference sr = new PhantomReference(obj)</code>，和幽灵引用关联的对象等价于没有被引用，随时可能被回收。所以如果不给幽灵引用注册引用队列，那这个幽灵引用就没有意义。<ul>
<li>如果<code>PhantomReference</code>注册了引用队列<code>ReferenceQueue</code>，当回收幽灵引用关联的对象<strong>之前</strong>(finalize()之后)，会将该幽灵引用放到引用队列中。</li>
<li>因为每个对象在回收之前，还会执行继承自<code>Object</code>的<code>finalize()</code>用来做一些资源清理的操作，但是JVM什么时间执行<code>finalize()</code>不是确定的。考虑一个场景，在要分配内存创建新的对象时，要确定某个对象要被回收才能分配。此时可以通过幽灵引用结合引用队列实现，当执行了<code>finalize()</code>会将要回收的对象关联的幽灵引用放到引用队列中。此时可以确定这个对象马上要被回收，可以分配内存。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt;(data, queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] get() &#123;</span><br><span class="line">        <span class="comment">// 会阻塞直到队列 非空。非空以后说明已经执行了要被回收的对象的finalize()，可以分配新的内存</span></span><br><span class="line">        queue.remove();  </span><br><span class="line">        <span class="comment">// 幽灵引用不会自动清空，要手动运行 </span></span><br><span class="line">        ref.clear(); </span><br><span class="line">        ref = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">111</span>];</span><br><span class="line">        <span class="comment">// 重新关联</span></span><br><span class="line">        ref = <span class="keyword">new</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt;(data, queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><code>WeakHashMap</code>中的<code>Entry</code>内部的<code>key</code>指向的对象可能会被GC回收，即使没有手动调用<code>remove()</code>或者<code>clear()</code>方法。因为<code>WeakHashMap</code>中的<code>Entry</code>继承自<code>WeakReference</code>，把<code>key</code>引用的对象和弱引用关联起来(<code>Entry</code>继承了<code>WeakReference</code>，也就是将<code>key</code>和<code>Entry</code>关联起来)在JVM进行垃圾回收时会将<code>key</code>引用的对象回收。每次执行<strong>get</strong>、<strong>put</strong>、<strong>resize()</strong>等操作时会根据引用队列提前判断<code>key</code>所引用的对象是否被回收来决定是否清除该<code>key</code>关联的<code>Entry</code>以及<code>Entry</code>中的<code>value</code>指向的对象,来尽量避免内存泄漏。</p>
<h2 id="部分源码分析-1"><a href="#部分源码分析-1" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h3><p><code>Entry</code>继承了<code>WeakReference</code>，此时<code>Entry</code>也是一个虚引用。每次创建新的<code>Entry</code>时会将key和Entry关联，并且中。当回收了<code>key</code>所引用的对象以后,会将<code>Entry</code>放到引用队列<code>queue</code>中。所以在每次操作时都会从引用队列中取一个<code>Entry</code>释放掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="comment">// 将key和Entry关联，并且给Entry注册一个引用队列queue</span></span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后续没写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="public-V-get-Object-key-1"><a href="#public-V-get-Object-key-1" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h3><p>根据key获取value，当调用gettable()时会调用expungeStaleEntries()，然后从引用队列中取出Entry,释放掉Entry以及Entry中的value。<br>在WeakHashMap定义的增、删、改、查方法中，都要调用gettable()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果传入的key是null就用Object代替</span></span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="comment">// 求hash值确定下标</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    <span class="comment">// 获取原始数组，并且执行getTable()还会调用expungeStaleEntries()</span></span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="comment">// 获取下标</span></span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    <span class="comment">// 找value</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// e.get()返回和Entry关联的key</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从引用队列中取出Entry释放掉Entry以及Entry中的value</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从引用队列中取出Entry</span></span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line">            <span class="comment">// 释放Entry(类似删除单链表节点)以及Entry中的value(将e.value=null)</span></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    <span class="comment">// 释放Entry中的value</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    <span class="comment">// 键值对数量减1</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.infoq.cn/article/cf-java-garbage-references" target="_blank" rel="noopener">Java 深度历险（四）——Java 垃圾回收机制与引用类型</a></li>
<li><a href="https://www.zfl9.com/java-ref.html" target="_blank" rel="noopener">Java 4种引用类型</a></li>
<li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/9-WeakHashMap.md" target="_blank" rel="noopener">WeakHashMap</a></li>
<li><a href="https://crowhawk.github.io/2017/08/29/collection_4/" target="_blank" rel="noopener">Java集合框架源码解读(4)——WeakHashMap</a></li>
</ul>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p><code>TreeMap</code>是基于红黑树实现的一种<code>Map</code>，对于get、put、remove时间复杂度是log(n)。元素是有序的，顺序是按照key的自然顺序或者是定义的<code>Comparator</code>。</p>
</li>
<li><p><code>TreeMap</code>不是线程安全的。如果需要线程安全的<code>TreeMap</code>需要使用<code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p>
</li>
<li><p><code>TreeMap</code>实现了<code>NavigableMap</code>间接实现了<code>SortedMap</code>。<strong>注意的是<code>SortedMap</code>比较两个<code>key</code>是否相等不是按<code>Map</code>中规定的<code>equals()</code>，而是用自己定义的<code>Comparator</code>中的<code>compareTo()</code>。</strong> <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">参考Java doc</a>：</p>
<blockquote>
<p><strong>This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are,</strong> from the standpoint of the sorted map, equal. The behavior of a sorted map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface.</p>
</blockquote>
</li>
</ul>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><p>因为是通过compareTo()比较两个key是否相等，如果compareTo()写错了会出现TreeMap中明明存在该key，并且equals()返回true，但是get()返回null。如下：(<a href="https://www.liaoxuefeng.com/article/001545657362937e0b6ff640a45422faec234c3f1f23f43000" target="_blank" rel="noopener">下面代码转自廖雪峰大神</a>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">            Student o = (Student) obj;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, o.name) &amp;&amp; <span class="keyword">this</span>.score == o.score;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score &lt; o.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>HashMap</code>测试能正常输出 99 88 77。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">"Michael"</span>, <span class="number">99</span>), <span class="number">99</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">88</span>), <span class="number">88</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">"Alice"</span>, <span class="number">77</span>), <span class="number">77</span>);</span><br><span class="line">System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Michael"</span>, <span class="number">99</span>)));</span><br><span class="line">System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">88</span>)));</span><br><span class="line">System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Alice"</span>, <span class="number">77</span>)));</span><br></pre></td></tr></table></figure>

<p>用<code>TreeMap</code>测试输出 null null null，因为通过hash确定下标后，通过compareTo()返回值是否为0找到key，但是现在compareTo()不会返回0…..，所以会找不到key，然后返回null。<br>重写<code>compareTo()</code>，<strong>保证当<code>key</code>相等时返回0</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integers.compare(<span class="keyword">this</span>.score,o.score);</span><br><span class="line">    <span class="keyword">return</span> result != <span class="number">0</span> ? result : <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">    <span class="comment">//return this.score &lt; o.score ? -1 : 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="一致性哈希-代码实现思路参照链接"><a href="#一致性哈希-代码实现思路参照链接" class="headerlink" title="一致性哈希 代码实现思路参照链接"></a>一致性哈希 <a href="https://www.cnkirito.moe/consistent-hash-lb/" target="_blank" rel="noopener">代码实现思路参照链接</a></h3><p>实现负载均衡，因为TreeMap提供了获取第一个大于当前节点的API，<code>ceilingEntry()</code></p>
<ol>
<li>建环</li>
<li>构造虚拟节点</li>
<li>接受请求，根据请求定位<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsitentHash</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚拟节点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个物理服务器中虚拟节点的分隔符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DILEMMA = <span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希策略</span></span><br><span class="line">    <span class="keyword">private</span> HashStrategy hashStrategy = <span class="keyword">new</span> JDKHashCodeStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Request request)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; hashRing = buildRing(servers);</span><br><span class="line">        <span class="keyword">return</span> locate(request, hashRing);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeMap&lt;Integer, Server&gt; <span class="title">buildRing</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; hashRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        servers.forEach(server -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++)</span><br><span class="line">                hashRing.put(hashStrategy.getHashCode(server.getUrl() + DILEMMA + i), server);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> hashRing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">locate</span><span class="params">(Request request, TreeMap&lt;Integer, Server&gt; hashRing)</span> </span>&#123;</span><br><span class="line">        Server server;</span><br><span class="line">        <span class="keyword">int</span> key = hashStrategy.getHashCode(request.getHashKey());</span><br><span class="line">        Map.Entry&lt;Integer, Server&gt; serverEntry = hashRing.ceilingEntry(key);</span><br><span class="line">        <span class="keyword">return</span> serverEntry == <span class="keyword">null</span> ? hashRing.firstEntry().getValue() : serverEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">JDKHashCodeStrategy</span> <span class="keyword">extends</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> origin.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String hashKey;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getHashKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hashKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHashKey</span><span class="params">(String hashKey)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hashKey = hashKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
      

  <div class="popular-posts-header">Related Posts</div>
  <ul class="popular-posts">
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2018/07/19/Collection/" rel="bookmark">Java容器框架源码阅读笔记（零）Collection、Map</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2018/07/20/List/" rel="bookmark">Java容器框架源码阅读笔记（一）List</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2018/07/22/Set/" rel="bookmark">Java容器框架源码阅读笔记（三）Set</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2018/07/21/Queue&&Stack/" rel="bookmark">Java容器框架源码阅读笔记（二）Queue、Stack</a></div>
      
    </li>
  
  </ul>


    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/JCF/" rel="tag"># JCF</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/22/Set/" rel="next" title="Java容器框架源码阅读笔记（三）Set">
                <i class="fa fa-chevron-left"></i> Java容器框架源码阅读笔记（三）Set
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/06/MyCache/" rel="prev" title="缓存实现思路">
                缓存实现思路 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/img/avatar-js.png" alt="Jin Shuai">
            
              <p class="site-author-name" itemprop="name">Jin Shuai</p>
              <div class="site-description motion-element" itemprop="description">万丈高楼平地起，勿在浮沙筑高塔</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/jinshuai86" title="GitHub &rarr; https://github.com/jinshuai86" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:jinshuai789@gmail.com" title="E-Mail &rarr; mailto:jinshuai789@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://rednaxelafx.iteye.com/category/22617" title="https://rednaxelafx.iteye.com/category/22617" rel="noopener" target="_blank">RednaxelaFX</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.coolshell.cn" title="https://www.coolshell.cn" rel="noopener" target="_blank">酷壳</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.liaoxuefeng.com" title="https://www.liaoxuefeng.com" rel="noopener" target="_blank">廖雪峰的官方网站</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap"><span class="nav-number">1.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#预备知识"><span class="nav-number">1.1.</span> <span class="nav-text">预备知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">1.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#部分源码分析"><span class="nav-number">1.3.</span> <span class="nav-text">部分源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量-常量"><span class="nav-number">1.3.1.</span> <span class="nav-text">变量/常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-Object-key"><span class="nav-number">1.3.2.</span> <span class="nav-text">get(Object key)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put-K-key-V-value"><span class="nav-number">1.3.3.</span> <span class="nav-text">put(K key, V value)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-V-remove-Object-key"><span class="nav-number">1.3.4.</span> <span class="nav-text">public V remove(Object key)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resize"><span class="nav-number">1.3.5.</span> <span class="nav-text">resize()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Q-amp-A"><span class="nav-number">2.</span> <span class="nav-text">Q&amp;A</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">4.</span> <span class="nav-text">LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍-1"><span class="nav-number">4.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#部分源码解析"><span class="nav-number">4.2.</span> <span class="nav-text">部分源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">4.2.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-afterNodeInsertion-boolean-evict"><span class="nav-number">4.2.2.</span> <span class="nav-text">void afterNodeInsertion(boolean evict)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-V-get-Object-key"><span class="nav-number">4.2.3.</span> <span class="nav-text">public V get(Object key)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#afterNodeRemoval-Node-lt-K-V-gt-e"><span class="nav-number">4.2.4.</span> <span class="nav-text">afterNodeRemoval(Node&lt;K,V&gt; e)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Q-amp-A-1"><span class="nav-number">5.</span> <span class="nav-text">Q&amp;A</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WeakHashMap"><span class="nav-number">6.</span> <span class="nav-text">WeakHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#预备知识-1"><span class="nav-number">6.1.</span> <span class="nav-text">预备知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的四种引用"><span class="nav-number">6.1.1.</span> <span class="nav-text">Java中的四种引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强引用-StrongReference"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">强引用(StrongReference)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软引用-SoftReference"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">软引用(SoftReference)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱引用-WeakReference"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">弱引用(WeakReference)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#幽灵引用-PhantomReference"><span class="nav-number">6.1.1.4.</span> <span class="nav-text">幽灵引用(PhantomReference)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍-2"><span class="nav-number">6.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#部分源码分析-1"><span class="nav-number">6.3.</span> <span class="nav-text">部分源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Entry结构"><span class="nav-number">6.3.1.</span> <span class="nav-text">Entry结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-V-get-Object-key-1"><span class="nav-number">6.3.2.</span> <span class="nav-text">public V get(Object key)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考-1"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TreeMap"><span class="nav-number">8.</span> <span class="nav-text">TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍-3"><span class="nav-number">8.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用注意"><span class="nav-number">8.2.</span> <span class="nav-text">使用注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景"><span class="nav-number">8.3.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性哈希-代码实现思路参照链接"><span class="nav-number">8.3.1.</span> <span class="nav-text">一致性哈希 代码实现思路参照链接</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jin Shuai</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.1</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  
  

<script>
  var disqus_config = function() {
    this.page.url = "https://github.jinshuai86.io/2018/07/23/Map/";
    this.page.identifier = "2018/07/23/Map/";
    this.page.title = 'Java容器框架源码阅读笔记（四）Map';
    };
  function loadComments() {
    var d = document, s = d.createElement('script');
    s.src = 'https://jinshuai86.disqus.com/embed.js';
    s.setAttribute('data-timestamp', '' + +new Date());
    (d.head || d.body).appendChild(s);
  }
  
    loadComments();
  
</script>





  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('Copied');
        else $(this).text('Copy failed');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('Copy');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
