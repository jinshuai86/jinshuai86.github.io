<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JinShuai&#39;s Blog</title>
  
  <subtitle>稳住别慌，问题不大</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.jinshuai86.io/"/>
  <updated>2022-07-25T17:31:40.648Z</updated>
  <id>https://github.jinshuai86.io/</id>
  
  <author>
    <name>Jin Shuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>J.U.C源码阅读笔记（五）线程池</title>
    <link href="https://github.jinshuai86.io/2020/04/23/ThreadPool/"/>
    <id>https://github.jinshuai86.io/2020/04/23/ThreadPool/</id>
    <published>2020-04-23T08:12:28.000Z</published>
    <updated>2022-07-25T17:31:40.648Z</updated>
    
    <content type="html"><![CDATA[<p>线程池是存放线程的容器，内部维护了若干个线程。通过利用线程池可以避免频繁创建线程，销毁线程带来的系统内耗，提高吞吐量。在Java中用<code>Thread</code>对线程做了抽象，线程池的实现类是<code>ThreadPoolExecutor</code>。但是线程之间的切换需要系统调用进内核，一旦线程池中线程的数量比较多，线程切换带来的内耗会制约系统吞吐量。协程(在Windows上称为纤程)本质上是用户态的线程，协程的调度不需要进内核，在用户态即可完成，所以相对线程，协程更加轻量。在Java中<a href="http://docs.paralleluniverse.co/quasar/" target="_blank" rel="noopener">Quasar</a>、 <a href="https://openjdk.java.net/projects/loom/" target="_blank" rel="noopener">Loom</a>库中实现了协程。</p><a id="more"></a><h1 id="Java线程池类结构"><a href="#Java线程池类结构" class="headerlink" title="Java线程池类结构"></a>Java线程池类结构</h1><p>下图是Java中关于线程池的类的组织架构。顶层接口是<code>Executor</code>，里面只有一个<code>execute(Runnable command)方法</code>,<code>ExecutorService</code>扩展了顶层接口，添加了关闭线程池等方法，<code>AbstractExecutorService</code> 实现了<code>ExecutorService</code>中的部分方法。而真正要用到的类是<code>ThreadPoolExecutor</code>。</p><p><img src="/img/in-post/post-java-juc/ThreadPoolExecutor.png" alt="线程池类的结构">  </p><h2 id="ThreadPoolExecutor部分源码解读"><a href="#ThreadPoolExecutor部分源码解读" class="headerlink" title="ThreadPoolExecutor部分源码解读"></a>ThreadPoolExecutor部分源码解读</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>ThreadPoolExecutor</code>主要属性包括线程池的状态以及线程池中工作线程的数量。<code>ThreadPoolExecutor</code>构造函数中包含了如下变量：</p><ul><li><code>corePoolSize</code> 核心线程数量</li><li><code>maximumPoolSize</code> 线程池所允许的最大线程数量</li><li><code>keepAliveTime</code> 线程存活时间（一般指<code>corePoolSize</code>和<code>maximumPoolSize</code>这些线程的存活时间，当调用<code>allowCoreThreadTimeout()</code>后，核心线程也可以超时退出）</li><li><code>TimeUnit</code> 超时单位（毫秒、秒等）</li><li><code>BlockingQueue</code> <a href="https://jinshuai86.github.io/2018/08/12/SynchronizedContainer/" target="_blank" rel="noopener">阻塞队列</a>用于存放任务</li><li><code>ThreadFactory</code> 创建线程的工厂，可以用来根据业务用来设置线程的名字</li></ul><h3 id="线程池状态属性"><a href="#线程池状态属性" class="headerlink" title="线程池状态属性"></a>线程池状态属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具数字，29。后面会用它进行位运算，创建线程池的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 工具数字，后面利用它计算线程池的状态和线程池中工作线程数量。</span></span><br><span class="line"><span class="comment">// 线程池中最大可以创建的线程数量（2^29 - 1）：00011111 11111111 11111111 11111111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用int的高 3 位表示[线程池]的状态，低 29 位存放线程池中工作线程数量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正在运行：允许接收任务，处理任务队列中的任务</span></span><br><span class="line"><span class="comment">// 11100000 00000000 000000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭状态：不再接收新的任务，但会处理任务队列中的任务</span></span><br><span class="line"><span class="comment">// 00000000 00000000 000000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止状态：不再接收新的任务，也不会处理任务队列中的任务，并且会中断正在执行任务的线程</span></span><br><span class="line"><span class="comment">// 00100000 00000000 000000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正在整理中：所有的任务都已经终止，工作线程数量为 0，然后就会执行钩子函数 terminated()，转到终止状态，可以重写钩子函数。</span></span><br><span class="line"><span class="comment">// 01000000 00000000 000000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止状态：线程池彻底终止，当处于TIDYING状态线程池执行完钩子函数terminated()就会转换成这个状态</span></span><br><span class="line"><span class="comment">// 01100000 00000000 000000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl高 3 位存储线程池的状态，低 29 位存储工作线程数量，ctl初始值为 -1。内部大量用到了ctl变量。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态（~CAPACITY = 11100000 00000000 00000000 00000000）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数（CAPACITY = 00011111 11111111 11111111 11111111）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure><h3 id="线程池状态转换"><a href="#线程池状态转换" class="headerlink" title="线程池状态转换"></a>线程池状态转换</h3><p>因为在创建工作线程以及任务执行过程中需要不断地的判断线程池状态，所以有必要了解:)</p><ul><li><p><code>RUNNING -&gt; SHUTDOWN</code>：On invocation of shutdown(), perhaps implicitly in finalize()  </p></li><li><p><code>(RUNNING or SHUTDOWN) -&gt; STOP</code>：On invocation of shutdownNow()  </p></li><li><p><code>SHUTDOWN -&gt; TIDYING</code>：When both queue and pool are empty  </p></li><li><p><code>STOP -&gt; TIDYING</code>：When pool is empty</p><blockquote><p>因为 <code>STOP</code> 状态不会在去处理队列中的任务，所以只需要考虑线程池中的线程数量</p></blockquote></li><li><p><code>TIDYING -&gt; TERMINATED</code>：When the terminated() hook method has completed  </p></li></ul><h3 id="执行任务源码"><a href="#执行任务源码" class="headerlink" title="执行任务源码"></a>执行任务源码</h3><h4 id="public-void-execute-Runnable-command"><a href="#public-void-execute-Runnable-command" class="headerlink" title="public void execute(Runnable command)"></a>public void execute(Runnable command)</h4><p>在将来某个时间执行给定的任务（将来的意思是任务可能会放到任务队列中），可能创建线程执行也可能利用现有的线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 线程池处理任务分为 3 个步骤：</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 步骤 1. </span></span><br><span class="line"><span class="comment">    * 如果当前工作线程数量少于核心线程数，会尝试通过 addWorker(Runnable fisrtTask, boolean core) 创建线程执行 "给定的任务"</span></span><br><span class="line"><span class="comment">    * 此时 firstTask 为给定的任务，core 为 true 代表工作线程数量边界为 "核心线程数量"</span></span><br><span class="line"><span class="comment">    * 但是由于意外情况，addWorker 可能会失败: 比如执行　addWorker　时线程池状态变为 Shutdown、Stop　或者由于系统资源不* 够（当前用户进程　limit 受限　ulimit -u），导致 new Thread() 直接失败(抛　can not create native thread 异常)</span></span><br><span class="line"><span class="comment">    * 所以如果 addworker 方法返回 false 说明存在意外情况导致创建失败，直接返回。</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 步骤 2. </span></span><br><span class="line"><span class="comment">    * 当步骤 1 不能处理时，说明当前线程数量 &gt;= 核心线程数量</span></span><br><span class="line"><span class="comment">    * 如果处于 RUNNING 状态，并且任务成功入队后，会二次判断线程池状态</span></span><br><span class="line"><span class="comment">    * 当处于未运行状态时会将刚才入队的任务出队，同时执行拒绝策略</span></span><br><span class="line"><span class="comment">    * 当工作线程数量为 0 时(线程超时退出、异常退出)，会尝试创建新的工作线程, 最终就是要保证，如果线程池处于正常状态，就务必要成功执行　addWorker()</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 步骤 3. </span></span><br><span class="line"><span class="comment">    * 当步骤 2 不能处理时，说明线程池没有运行或者队列已经满了，此时会尝试创建新的工作线程</span></span><br><span class="line"><span class="comment">    * 通过将 core 设置为 false，此时工作线程数量的边界为最大线程数量</span></span><br><span class="line"><span class="comment">    * 如果创建工作线程失败，代表线程池处于未运行状态或者已经饱和，会尝试执行拒绝策略</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 对应上述步骤 1</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应上述步骤 2</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池已经关闭，需要移除之前提交到队列中的任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 防止线程池没有关闭，但是工作线程数量为0(因为线程有存活时间或者出现异常情况)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) </span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应步骤 3</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="private-boolean-addWorker-Runnable-firstTask-boolean-core"><a href="#private-boolean-addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="private boolean addWorker(Runnable firstTask, boolean core)"></a>private boolean addWorker(Runnable firstTask, boolean core)</h4><p>创建工作线程，每个 Worker 内部维护一个Thread，也可以想成每个　Worker　是对　Thread　的抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 步骤1. 检查线程池的状态</span></span><br><span class="line"><span class="comment">         * 如果处于SHUTDOWN、STOP、TIDYING、TERMINATED状态时，一般就不再创建新的线程了，但是要处理一种特殊情况:</span></span><br><span class="line"><span class="comment">         * 当线程池状态处于 SHUTDOWN 时，尽管不需要处理新来的任务，但是需要处理完阻塞队列中的任务</span></span><br><span class="line"><span class="comment">         * 所以，当线程池状态为 SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()，还会允许添加　Worker　执行队列中的任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 步骤2. 判断当前线程数量和边界值，修改　worker　值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 比较工作线程数量和边界CAPACITY，CAPACITY根据core的值动态调整</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 尝试将c中保存的工作线程数量加 1，</span></span><br><span class="line">            <span class="comment">// 如果修改成功，会通过break，跳出外层循环到retry。</span></span><br><span class="line">            <span class="comment">// 如果修改失败，说明有并发操作，此时会比较当前线程池的状态和进入这个方法时线程池的状态</span></span><br><span class="line">            <span class="comment">// 　　　如果状态不一致，说明线程池状态发生的变化，会通过continue重新进入外层for循环，重新走一遍逻辑，避免在线程池关闭之类的状态下执行后续的操作</span></span><br><span class="line">            <span class="comment">//      如果状态一致，会重新在内层for循环中尝试修改ctl</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 判断当前线程池的状态和进入这个方法时线程池的状态是否一致</span></span><br><span class="line">            c = ctl.get(); </span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 步骤3. 正式创建工作线程并启动它。</span></span><br><span class="line"><span class="comment">     * Thread会被封装到Worker中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 工作线程是否启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 工作线程是否已经创建</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建工作线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 获取到锁以后才尝试创建线程，因为在关闭线程池时也需要获取到这把锁</span></span><br><span class="line">            <span class="comment">// 为了防止 [当关闭线程池以后并且也释放了这把锁]，当获取到锁后还会重新检测线程池的状态，拿到锁以后，也就避免此时不会关闭线程池</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 只有线程池正在运行 或者 处于前面说的特殊情况</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 将包装的Worker放到集合中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 记录线程池中线程数量的峰值，统计用。</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功创建worker以后，会将worker中包装的Thread启动</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动Woker类里的Thread对象，因为Worker实现了Runnable</span></span><br><span class="line">                <span class="comment">// 此时新创建的线程就会执行Worker中的run()方法。</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 启动线程出现意外情况，执行相应的处理方法</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="private-void-addWorkerFailed-Worker-w"><a href="#private-void-addWorkerFailed-Worker-w" class="headerlink" title="private void addWorkerFailed(Worker w)"></a>private void addWorkerFailed(Worker w)</h4><p>处理 [创建工作线程出现的失败情况]，会将之前放到集合中的<code>Worker</code>对象移除，并且将<code>ctl</code>变量中保存的工作线程数量减<code>1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 添加线程失败，线程池可能处于异常状态，尝试中断线程</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-void-run"><a href="#public-void-run" class="headerlink" title="public void run()"></a>public void run()</h4><p>创建的线程会从run方法开始执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为runWorker(Worker w)的代理方法，在Worker中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ThreadPoolExecutor中实现</span></span><br><span class="line"><span class="comment">// 整体逻辑就是不断地的从任务队列中取任务执行</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="comment">// 因为线程会被复用，将firstTask置为空避免重复执行</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 允许被中断（当调用shutdownnow时，需要获取锁 w ，然后中断 w 封装的线程）</span></span><br><span class="line">    w.unlock(); </span><br><span class="line">    <span class="comment">// 用于判断线程是否是在执行用户任务过程中出现的异常退出的</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 如果线程池处于未运行状态，需要确保当前线程被中断</span></span><br><span class="line">            <span class="comment">// 否则，需要确保当前线程不能被中断</span></span><br><span class="line">            <span class="comment">// 重复调用 runStateAtLeast(ctl.get(), STOP) 是为了避免边界条件：</span></span><br><span class="line">            <span class="comment">// 第一次runStateAtLeast(ctl.get(), STOP)返回false，当执行 || 右侧的Thread.interrupted()时，线程池停止了，但还没中断当前线程</span></span><br><span class="line">            <span class="comment">// 此时需要线程自我中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="comment">// beforeExecute(wt, task); 和 afterExecute(task, thrown); 都是钩子方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 正式执行用户提交的任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 记录完成的任务数量</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 当线程在执行任务中抛了异常，会转到这里</span></span><br><span class="line">        <span class="comment">// 此时当前线程结束，如果线程池没有关闭，会重新创建一个线程代替当前线程</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="private-Runnable-getTask"><a href="#private-Runnable-getTask" class="headerlink" title="private Runnable getTask()"></a>private Runnable getTask()</h4><p>线程会不断地尝试获取任务，当取任务超时后，会在符合预先条件的情况下结束当前线程：<br>此时<code>getTask()</code>会返回null，线程结束在<code>runWorker(Worker w)</code>中的<code>while</code>循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标识线程是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="comment">// 直到超时、线程池关闭或者拿到任务才会退出</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断线程池是否关闭，如果关闭了，符合特殊情况：（SHUTDOWN并且工作队列为空）或 （线程池状态是STOP及以上）</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 减少线程数</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="comment">// 返回null以后，这个线程会正常结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否允许[所有]线程超时退出</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">// 如果用户调用了setMaximumPoolSize()会导致wc &gt; maximumPoolSize</span></span><br><span class="line">        <span class="comment">// 如果 （允许所有线程超时 或者 当前线程数量已经超过corePoolSize） 并且当前线程已经超时了 </span></span><br><span class="line">        <span class="comment">// 此时需要结束当前线程（通过返回null）</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 阻塞获取任务，如果在指定时间段内没有获取到，会返回null</span></span><br><span class="line">            <span class="comment">// timed表示是否应该超时获取，注意此处也是　keepAliveTime　起作用的地方</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="comment">// 未超时的情况下获取到了任务，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 超时了，下次进入循环中时会返回null</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 被中断了会重试：可能调用setMaximumPoolSize方法，setMaximumPoolSize执行会中断线程</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-interface-RejectedExecutionHandler"><a href="#public-interface-RejectedExecutionHandler" class="headerlink" title="public interface RejectedExecutionHandler"></a>public interface RejectedExecutionHandler</h4><p><code>ThreadPoolExecutor</code>基于<code>RejectedExecutionHandler</code>提供了四种拒绝策略，自己也可以基于<code>RejectedExecutionHandler</code>定制拒绝策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让提交任务的线程去执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接拒绝，并且抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                                <span class="string">" rejected from "</span> +</span><br><span class="line">                                                e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接丢弃，不抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢弃任务队列中最老的任务，也就是队列中队头，然后重新尝试将当前任务入队。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查调用 shutdown 的线程是否权限关闭线程池（针对里面的每个worker）</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 死循环修改线程池状态为 SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ScheduledThreadPoolExecutor-源码解读"><a href="#ScheduledThreadPoolExecutor-源码解读" class="headerlink" title="ScheduledThreadPoolExecutor 源码解读"></a>ScheduledThreadPoolExecutor 源码解读</h2><p><code>ScheduledThreadPoolExecutor</code> 为定时线程池，　可以周期性的执行任务，文档：</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="线程池工作流程？"><a href="#线程池工作流程？" class="headerlink" title="线程池工作流程？"></a>线程池工作流程？</h2><p><img src="/img/in-post/post-java-juc/ThreadPoolWorkflow.png" alt="线程池工作流"></p><h2 id="线程池的种类？"><a href="#线程池的种类？" class="headerlink" title="线程池的种类？"></a>线程池的种类？</h2><p>线程池的种类也就是<strong>线程池工具类</strong> <code>Executors</code>中提供的线程池，实际上也就是通过调整<code>ThreadPoolExecutor</code>以及<code>ScheduledThreadPoolExecutor</code>构造函数中的参数。不过阿里巴巴手册中不建议用这个工具类，所以就简单看一下在<code>ThreadPoolExectuor</code>的构造函数中如何“搭配”变量。</p><ul><li><p>固定数量的线程池：核心线程和最大线程数量一样。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure></li><li><p>单线程线程池：核心线程和最大线程数量都为1  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure></li><li><p>缓存线程池：最大线程数量为<code>Integer.MAX_VALUE</code>也可以认为是无界的，尽管会提高性能，但一般不会用这个，因为会创建大量的线程执行。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure></li><li><p>定时线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程在执行任务中出现异常会怎么办？"><a href="#线程在执行任务中出现异常会怎么办？" class="headerlink" title="线程在执行任务中出现异常会怎么办？"></a>线程在执行任务中出现异常会怎么办？</h2><p>参照<code>runWorker()</code>中，当线程在执行任务时抛出了异常，会触发<code>processWorkerExit(w, completedAbruptly);</code>此时当前线程结束，如果线程池没有关闭，会重新创建一个线程代替当前线程</p><h2 id="执行拒绝策略的时刻？"><a href="#执行拒绝策略的时刻？" class="headerlink" title="执行拒绝策略的时刻？"></a>执行拒绝策略的时刻？</h2><ul><li>达到边界条件：任务队列满了，工作线程数量达到最大线程数量。</li><li>非边界条件：当工作线程数量达到了核心线程数量，此时如果入队成功 =&gt; 如果线程池已经关了，会尝试移除刚才入队的任务。如果移除成功 =&gt; 会执行拒绝策略</li></ul><h2 id="拒绝策略使用注意事项？"><a href="#拒绝策略使用注意事项？" class="headerlink" title="拒绝策略使用注意事项？"></a>拒绝策略使用注意事项？</h2><p>注意在使用　Future 同时使用　Discard　策略时，注意设置超时时间，因为当执行了这个策略后，后续又执行了　Future.get()，此时会卡住当前线程，所以需要加上超时时间或者使用其他拒绝策略</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.javadoop.com/post/java-thread-pool" target="_blank" rel="noopener">深度解读 java 线程池设计思想及源码实现</a></li><li><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/concurrent/ThreadPoolExecutor.java" target="_blank" rel="noopener">OpenJDK8 ThreadPoolExecutor源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程池是存放线程的容器，内部维护了若干个线程。通过利用线程池可以避免频繁创建线程，销毁线程带来的系统内耗，提高吞吐量。在Java中用&lt;code&gt;Thread&lt;/code&gt;对线程做了抽象，线程池的实现类是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。但是线程之间的切换需要系统调用进内核，一旦线程池中线程的数量比较多，线程切换带来的内耗会制约系统吞吐量。协程(在Windows上称为纤程)本质上是用户态的线程，协程的调度不需要进内核，在用户态即可完成，所以相对线程，协程更加轻量。在Java中&lt;a href=&quot;http://docs.paralleluniverse.co/quasar/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Quasar&lt;/a&gt;、 &lt;a href=&quot;https://openjdk.java.net/projects/loom/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Loom&lt;/a&gt;库中实现了协程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JUC" scheme="https://github.jinshuai86.io/tags/JUC/"/>
    
      <category term="多线程" scheme="https://github.jinshuai86.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式学习笔记</title>
    <link href="https://github.jinshuai86.io/2019/06/03/Design-Pattern/"/>
    <id>https://github.jinshuai86.io/2019/06/03/Design-Pattern/</id>
    <published>2019-06-03T09:25:43.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>In software engineering, <strong>a software design pattern is a general, reusable solution</strong> to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. <strong>It is a description or template for how to solve a problem that can be used in many different situations.</strong> Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system.</p></blockquote><p><a style="float: right" href="https://en.wikipedia.org/wiki/Software_design_pattern" target="_blank" rel="noopener">— Wikipedia</a><br></p><a id="more"></a><p>总结一下，设计模式就是针对某类问题提出的通用的、可复用的最佳实践。设计模式一共分为三大类，分别是创建型模式、结构型模式、行为型模式。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">维基百科-设计模式</a></li><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a></li><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">Head First 设计模式</a></li></ul><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型模式的作用就是用来创建对象，在不同的上下文中以合适的方式创建对象。<br>创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式把对象创建的一部分推迟到<strong>另一个对象</strong>中，而类创建型模式将它对象的创建推迟到<strong>子类</strong>中。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>定义一个工厂类，根据客户端传入的不同参数，返回不同的对象，<strong>返回的对象同属一个父类。</strong></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>工厂类负责创建的对象较少，客户端不需要知道指定类的名字，只需要知道表示该类的一个参数，并提供一个方法，将该参数传入该方法就可以很方便地获取该类的实例。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><p>产品工厂：负责创建所有产品的工厂，负责实现创建所有产品的逻辑</p></li><li><p>抽象产品：所有具体产品的父类</p></li><li><p>具体产品：产品工厂具体要创建的产品实例</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>简单工厂模式可以分担客户端创建对象的责任，客户端只需要使用对象即可，符合类的单一职责原则，有利于解耦合。</li></ul></li><li>缺点<ul><li>当增加新的产品时，需要修改原有工厂代码，不符合开闭原则。</li><li>工厂类负责了所有对象的创建，当要创建的对象过多的话，业务逻辑过于复杂，职责过重。</li></ul></li></ul><h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中的用于格式化时间的<code>DateFormat</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style, Locale locale)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>不同类型的对象使用不同的工厂创建，通过定义一个创建对象的接口，但让实现这个接口的类来决定负责创建哪个类的实例</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>如果在未来可能会增加新的产品类型，此时用简单工厂模式的话，需要修改原有工厂模式中的代码(添加额外的判断逻辑)，违反了开闭原则，扩展性不好。使用工厂方法模式的话，只需要添加一个针对此产品类型的工厂即可，符合开闭原则。</p><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象工厂：定义了创建对象的方法，所有创建对象的具体工厂需要实现这个接口，重写创建对象的方法。</li><li>具体工厂：用来创建具体类型产品的实例</li><li>抽象产品：所有具体类型产品的父类</li><li>具体产品：具体要创建的产品类型，不同类型的产品使用不同的工厂创建</li></ul><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>避免了简单工厂模式中的由单一工厂创建所有对象的职责。符合对扩展开放，对修改关闭的原则。</li></ul></li><li>缺点<ul><li>当增加新产品类型时需要定义新的产品类和与之对应的具体工厂类，导致类的数量成对增加，增加了系统的复杂度。</li></ul></li></ul><h3 id="具体应用-1"><a href="#具体应用-1" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中的<code>Iterator</code>和<code>Collection</code>。<code>Iterator</code>相当于一个抽象产品，具体的产品有<code>Itr</code>、<code>KeyIterator</code>。<code>Collection</code>相当于一个抽象工厂，具体的工厂有<code>ArrayList</code>负责创建具体的<code>Itr</code>,<code>HashSet</code>负责创建具体的<code>KeyIterator</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List iteratorFactory = <span class="keyword">new</span> ArrayList(); <span class="comment">// 具体工厂</span></span><br><span class="line"></span><br><span class="line">Iterator iterator = iteratorFactory.iterator();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123; <span class="comment">// 抽象产品</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>; <span class="comment">// 具体产品</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Set iteratorFactory = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 具体工厂</span></span><br><span class="line"></span><br><span class="line">Iterator iterator = iteratorFactory.iterator();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123; <span class="comment">// 抽象产品</span></span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> // 具体的产品</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>提供一个创建<strong>一系列</strong>相关或独立对象的接口，而无须指定这些对象的具体类。在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法创建不同类型的产品，这些产品构成了一个产品族。</p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>当需要工厂负责创建多个对象时，而不是单一对象。需要用到抽象工厂模式。抽象工厂模式面向的是产品族，通过将<strong>一系列</strong>的产品组成一个产品族，交给一个具体工厂去创建。</p><h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象工厂： 声明了<strong>一组</strong>创建一族产品的<strong>方法</strong>，每一个方法负责创建一种具体类型的产品。</li><li>具体工厂： 每一个具体工厂负责创建<strong>一组</strong>产品，这组产品属于一个产品族</li><li>抽象产品： 某种具体类型产品的父类</li><li>具体产品： 某种具体的产品</li></ul><h3 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>减小了工作量，避免了工厂方法模式中，每次添加一个新的产品，都需要添加一个具体的工厂类与之对应。</li><li>会保证客户端使用的都是一个产品族中的产品</li><li>当增加新的<strong>产品族</strong>时，不用修改现有的业务逻辑，符合开闭原则。</li></ul></li><li>缺点<ul><li>当增加新的<strong>产品等级</strong>(产品类型)，需要修改抽象工厂(添加创建该产品的方法)以及所有的具体工厂，违背了开闭原则。</li></ul></li></ul><h3 id="具体应用-2"><a href="#具体应用-2" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中的<code>java.sql</code>中的<code>Connection</code>是抽象工厂，具体的工厂有<code>MysqlCollectionImpl</code>，里面有创建不同产品中的API，负责创建<code>Statement</code>、<code>PreparedStatement</code>、<code>CallableStatement</code>一系列抽象产品，具体产品有<code>StatementImpl</code>、<code>PreparedStatementImpl</code>、 <code>CallableStatementImpl</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">CallableStatement <span class="title">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>确保应用中某一个类只有一个该类的实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>系统只需要一个实例对象，比如只需要一个工具类对象负责读取配置信息。</p><h3 id="角色-3"><a href="#角色-3" class="headerlink" title="角色"></a>角色</h3><ul><li>单例类：负责创建该类的实例</li></ul><h3 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>保证整个应用中只有一个该类的实例，避免了频繁的创建对象和销毁对象，节约系统资源。</li></ul></li><li>缺点<ul><li>将创建对象的职责和执行业务逻辑的职责都交给单例对象，违背了单一职责原则。</li><li>单例模式没有做抽象，所以扩展性比较差。</li></ul></li></ul><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><ul><li>JDK中的 <code>RunTime</code>符合单例模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RunTime runTime = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentRuntime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>饿汉式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双检测 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载InnerClass的初始化阶段是线程安全的，并且只会加载一次。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>通过抽象一个建造者来完成对复杂对象的属性注入，使得代码的可读性更好。</p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>当构建的对象中含有较多的属性时，如果使用构造函数或者setter方法注入的话，整体的代码会比较臃肿。使用建造者模式可以让代码更加优雅一些。</p><h3 id="角色-4"><a href="#角色-4" class="headerlink" title="角色"></a>角色</h3><ul><li><p>抽象建造者：为创建一个复杂对象的各个组件(属性)指定API，以及一个返回该复杂对象的API</p></li><li><p>具体建造者：实现了抽象建造者中定义的API</p></li><li><p>产品：要被构造的复杂对象</p></li></ul><h3 id="特性-4"><a href="#特性-4" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>优化了复杂对象的创建<strong>等</strong>，，，相关的博客说了一堆优点，但是并没有完全理解，不想写了:)</li></ul></li><li>缺点<ul><li>如果产品内部变化复杂，此时就需要定义多个建造者来完成对象的创建，使得系统更复杂。</li></ul></li></ul><h3 id="具体应用-3"><a href="#具体应用-3" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中的<code>DocumentBuilder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setEntityResolver</span><span class="params">(EntityResolver er)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setErrorHandler</span><span class="params">(ErrorHandler eh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Document <span class="title">newDocument</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>克隆一个已有的对象。</p><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>当需要某个对象作为模板时，只需要在基于这个对象克隆出的对象的基础上，做少量修改就可以得到想要的对象。比如现实中的周报，可以提供一个模板，每个人在这个模板的基础上做少量修改就可以。</p><h3 id="具体应用-4"><a href="#具体应用-4" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中的<code>clone()</code>可以实现原型模式，不过主要注意的是默认是浅拷贝，如果要克隆的对象含有非原始类型的属性需要重写<code>clone()</code>，实现深拷贝。 另一个就是<code>clone()</code>默认是由<code>protected</code>修饰，只有子类和当前包的类可以访问，如果要让其它类访问的话，需要将<code>protected</code>修改为<code>public</code>。最后就是被克隆的对象要实现<code>Cloneable</code>接口:)</p><hr><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>通过将类组织成不同的结构，达到解耦合或者是做类增强功能。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>创建目标对象的一个代理对象，来代替目标对象接收客户端请求，代理对象内部维护了目标对象的引用，最终调用目标对象完成客户端的请求，<strong>在请求前后可以加上额外的业务逻辑来做对方法进行 “包装” 做增强功能。</strong>(TODO：个人理解)</p><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于一些非业务逻辑比如记录日志，开启事务，如果和业务代码写在一块，使得整体的耦合性较高，此时可以通过创建代理对象，在执行目标对象方法之前之后加上记录日志的功能来做类增强。</p><h3 id="角色-5"><a href="#角色-5" class="headerlink" title="角色"></a>角色</h3><ul><li><p>代理类：负责接口客户端请求，要“表现”的和目标类一样，所以要继承自目标类，不过内部持有目标类的引用</p></li><li><p>目标类：真正执行客户端的请求</p></li></ul><h3 id="特性-5"><a href="#特性-5" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>将业务代码和非业务代码分离，实现松耦合</li></ul></li><li>缺点<ul><li>增加了对代理对象的访问，请求会先到达代理对象，然后再到达目标对象，效率会有影响。</li></ul></li></ul><h3 id="具体应用-5"><a href="#具体应用-5" class="headerlink" title="具体应用"></a>具体应用</h3><ul><li><p>Spring AOP中用到的是动态代理，通过<code>@Aspect</code>定义一个切面，然后通过<code>@PointCut</code>确定一个切点，在切点前后执行额外的业务逻辑<code>@Advice</code>，执行的时机可以是<code>@Before</code>、<code>@After</code>、<code>@Around</code>  </p></li><li><p>Windows里面的快捷方式就是代理对象</p></li></ul><hr><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>通过创建装饰器来装饰对象，对已有对象的功能进行扩展，增强。每一个装饰器内部都维护了抽象对象的引用，可以调用抽象对象的方法，并且可以添加额外的增强方法。</p><h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><p>当不适合用继承的方式对系统进行扩展时，比如系统中存在大量独立的扩展类，如果扩展类之间组合会生成大量的类，此时可以使用装饰者模式</p><h3 id="角色-6"><a href="#角色-6" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象组件：是具体组件和抽象装饰器的父类，抽象装饰器内部维护了抽象组件的引用，使得可以装饰所有的具体组件</li><li>具体组件：要被装饰的具体组件，继承自抽象组件</li><li>抽象装饰器：内部维护了抽象组件的引用，所以可以调用抽象组件的方法</li><li>具体装饰器：继承自抽象装饰器，并且内部有新的方法，来对具体组件做增强功能</li></ul><h3 id="特性-6"><a href="#特性-6" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>当扩展一个对象的功能时，装饰者模式采用类组合来代替继承，不会导致类的数量大幅度增加。</li></ul></li><li>缺点<ul><li>当对类装饰以后，无法面向接口(抽象)编程，否则无法使用装饰的功能，因为装饰的功能都在具体的装饰器里面。</li></ul></li></ul><h3 id="具体应用-6"><a href="#具体应用-6" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中的IO框架，抽象组件是<code>InputStream</code>，具体组件有<code>FileInputStream</code>,抽象装饰器是<code>FilterInputStram</code>，具体的装饰器有<code>BufferedInputStream</code>、<code>DataInputStream</code></p><hr><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>通过引入适配器将不兼容的类适配，让这些类的可以一块工作。<br>适配器模式分为对象适配器和类适配器两种，对象适配器指适配者和适配器之间是组合的关系，类适配器指适配者和适配器之间是继承的关系。</p><h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于已经定义好的接口，但是并没有具体的实现， 不过现有的类可以提供这个接口中定义的功能，但是这个类并没有现成的源代码，比如说只有一个编译好的jar包，此时可以引入一个适配器，适配器实现这个接口，内部持有这个类的引用，通过使用这个类中的功能，间接实现这个接口。</p><h3 id="角色-7"><a href="#角色-7" class="headerlink" title="角色"></a>角色</h3><ul><li>被适配者：已经定义好的接口，但是并没有具体的实现</li><li>适配器：将适配者和被适配者适配到一块</li><li>适配者：已经有接口中定义的功能，但是和这个接口并不兼容。</li></ul><h3 id="特性-7"><a href="#特性-7" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>实现类的复用，通过适配器复用已有的可以提供服务但是和被适配者不兼容的适配者类</li></ul></li><li>缺点<ul><li>说的没理解:) TODO：继续看</li></ul></li></ul><h3 id="具体应用-7"><a href="#具体应用-7" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中IO框架里的<code>InputStreamReader</code>将<code>InputStream</code>适配成<code>Reader</code></p><hr><h2 id="外观-门面-模式"><a href="#外观-门面-模式" class="headerlink" title="外观(门面)模式"></a>外观(门面)模式</h2><p>通过创建一个门面角色完成客户端和其它多个子系统<strong>复杂</strong>的交互流程。</p><h3 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h3><p>当系统中类与类之间的交互关系比较复杂，比较多时，比如客户端需要和多个子系统进行交互，可以引入一个外观角色来和这些子系统进行交互。</p><h3 id="角色-8"><a href="#角色-8" class="headerlink" title="角色"></a>角色</h3><ul><li>门面角色：内部持有子系统的引用，将客户端的请求委派给子系统处理。</li><li>子系统：执行门面角色传过来的客户端的请求</li></ul><h3 id="特性-8"><a href="#特性-8" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>降低解除了子系统和客户端的耦合性</li></ul></li><li>缺点<ul><li>当需要修改和子系统交互的执行流程时，需要修改门面角色的代码，违背了开闭原则。</li></ul></li></ul><h3 id="具体应用-8"><a href="#具体应用-8" class="headerlink" title="具体应用"></a>具体应用</h3><p>slf4j相当于一个门面，而Log4J、Log-Back就是子系统。</p><hr><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式重点关注的是类之间的相互作用，将职责划分清楚。</p><h2 id="策略者模式"><a href="#策略者模式" class="headerlink" title="策略者模式"></a>策略者模式</h2><p>策略者模式是指完成一件事情，在不同的上下文里可以采用不同的策略。具体采用哪种策略根据上下文决定</p><h3 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h3><p>系统可以选择多种算法来完成某件事情，具体选用那种算法可以根据问题的上下文决定</p><h3 id="角色-9"><a href="#角色-9" class="headerlink" title="角色"></a>角色</h3><ul><li>上下文：问题的上下文</li><li>抽象策略：为了给客户端呈现统一的接口</li><li>具体策略：对于抽象策略的不同实现</li></ul><h3 id="特性-9"><a href="#特性-9" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>当需要不同的策略时，只需要新创建一个新的策略即可，符合开闭原则。</li></ul></li><li>缺点<ul><li>可能一些细微的改动，就得创建新的策略，需要创建的类会急剧增加</li></ul></li></ul><h3 id="具体应用-9"><a href="#具体应用-9" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中<code>ThreadPoolExecutor</code>中的四种拒绝策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span></span>; <span class="comment">// 抽象策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者通过订阅它感兴趣的事件，当事件发生时会通知之前订阅它的观察者。</p><h3 id="应用场景-11"><a href="#应用场景-11" class="headerlink" title="应用场景"></a>应用场景</h3><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，也就是说其它一些对象依赖某一个对象，当这个对象发生改变时，其它这些对象也会跟着变化，也就是一种联动的状态。</p><h3 id="角色-10"><a href="#角色-10" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象观察者：定义了具体要做什么动作的方法</li><li>具体观察者：做了具体的实现</li><li>抽象观察目标</li><li>具体目标：当具体目标发生变化时，会通知订阅它的观察者</li></ul><h3 id="特性-10"><a href="#特性-10" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>观察者模式适合广播通信，观察目标会对所有已经订阅的观察者发送通知</li></ul></li><li>缺点<ul><li>如果一个观察目标有很多观察者的话，通知所有的观察者会浪费很多的时间</li></ul></li></ul><h3 id="具体应用-10"><a href="#具体应用-10" class="headerlink" title="具体应用"></a>具体应用</h3><p>JDK中对观察者模式做了实现，<code>Observer</code>是观察者 <code>Observerable</code>是观察目标</p><hr><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>将处理请求的多个处理对象链接成一个链，当请求过来以后，会从链头逐个向链中的节点发送请求。</p><h3 id="应用场景-12"><a href="#应用场景-12" class="headerlink" title="应用场景"></a>应用场景</h3><p>一个处理流程需要多个处理人来处理，每个处理人可能有权限处理，可能没权限处理，并且这个处理流程是动态变化的</p><h3 id="角色-11"><a href="#角色-11" class="headerlink" title="角色"></a>角色</h3><ul><li>抽象处理者：定义了处理请求的API</li><li>具体处理者：对API做了实现，如果当前处理者没有权限处理，就转交给下一节点处理</li></ul><h3 id="特性-11"><a href="#特性-11" class="headerlink" title="特性"></a>特性</h3><ul><li>优点<ul><li>可以应付一些动态的处理流程，如果新加处理对象后，只需要客户端重新建链即可。</li></ul></li><li>缺点<ul><li>处理流程过长会影响效率</li></ul></li></ul><h3 id="具体使用-1"><a href="#具体使用-1" class="headerlink" title="具体使用"></a>具体使用</h3><p>JDK中的类加载器，当AppClassLoader接到类加载请求以后，会交给它的下一节点ExtensionClassLoader，然后交给BootStrapClassLoader。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;In software engineering, &lt;strong&gt;a software design pattern is a general, reusable solution&lt;/strong&gt; to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. &lt;strong&gt;It is a description or template for how to solve a problem that can be used in many different situations.&lt;/strong&gt; Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a style=&quot;float: right&quot; href=&quot;https://en.wikipedia.org/wiki/Software_design_pattern&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;— Wikipedia&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://github.jinshuai86.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux IO模型</title>
    <link href="https://github.jinshuai86.io/2018/12/03/Socket/"/>
    <id>https://github.jinshuai86.io/2018/12/03/Socket/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p>Linux网络IO模型分为同步和异步两种，其中同步IO又包括阻塞IO、非阻塞IO、IO多路复用、信号驱动式IO四种。</p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li><p>在<a href="https://en.wikipedia.org/wiki/Everything_is_a_file" target="_blank" rel="noopener">Unix</a>中,所有东西都是文件,<strong>文件</strong>可以看作是<strong>字节序列</strong>。所有的IO设备都可以用文件来描述(文件是对IO设备的抽象):</p><ul><li><code>./dev/sda2</code> (/usr 磁盘分区)</li><li><code>/dev/tty2</code> (终端)</li></ul></li><li><p>主要有三种文件<strong>类型</strong></p><ul><li>普通文件:包含任意数据<ul><li>文本文件:由ASCII或者Unicode组成</li><li>二进制文件:除文本文件外,都是二进制文件(视频,图片,声音)</li></ul></li><li>目录文件:一组文件的索引</li><li>Socket文件:用来和其它进程跨网络通信的文件</li></ul></li><li><p>对文件的操作主要有打开文件、读取文件、关闭文件</p><ul><li><p>打开文件</p><ul><li><p>进程通过系统调用(<code>open()</code>),内核会将文件名转换为一个文件描述符返回给进程(文件描述符是一个整数,进程可以用文件描述符作为索引对应打开的文件).</p></li><li><p>内核用三个数据结构表示打开的文件,分别是描述符表(descriptor table)、文件列表(file table)、文件列表的描述表(v-node table)。</p><ul><li><p>描述符表</p><ul><li>每个进程都有<strong>独立的</strong>描述符表，它的表项是由文件描述符索引的，每个打开的文件描述符<strong>表项</strong>指向文件列表中的一个表项。(可以把描述符表当成是一个数组，数组元素类型是文件列表表项，数组下标是文件描述符)</li></ul></li><li><p>文件列表</p><ul><li>文件列表是所有进程<strong>已经打开的</strong>文件的集合，由内核维护，所有进程<strong>共享</strong>。每个表项由当前文件的位置、引用计数(即当前志向该表项的描述符表项数)，以及一个指向v-node表的指针。冠以一个文件描述符会减少相应的引用计数。当引用计数为0时内核会删除这个文件列表表项</li></ul></li><li><p>文件列表描述表</p><ul><li>文件列表的元数据表，由内核维护，所有进程<strong>共享</strong>。</li></ul><p><img src="/img/in-post/post-network/fileDescriptor.jpg" alt="文件数据结构"></p></li></ul></li></ul></li></ul></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li><p><strong>Socket是</strong>用来与另一个进程进程进行网络通信的<strong>文件类型</strong>。进行通信的进程通过系统调用(<code>socket()</code>)创建Socket类型文件，通过读写该文件进行通信。通信过程：</p></li><li><p>客户端进程</p><ul><li><code>socket()</code>创建<strong>主动型</strong>socket文件(此时的socket还不能使用)</li><li><code>connect()</code>发起请求来和服务器建立连接，此时会阻塞线程，直到连接建立(此时socket才可以读写)或者连接失败返回。</li></ul></li><li><p>服务器进程</p><ul><li><code>socket()</code>创建<strong>主动型</strong>socket文件(此时的socket还不能使用)</li><li><code>bind()</code>绑定到指定的端口</li><li><code>listen()</code>将主动型socket改为监听型socket</li><li><code>accept()</code>等待客户端发起请求，进而针对该socket请求创建对应的主动型socket(不同于服务器进程创建的socket文件)，服务器进程通过对主动型的socket进行读写来和客户端进行通信。</li></ul><p><img src="/img/in-post/post-network/cs1.png" alt="1"></p></li></ul><h2 id="IO操作-IO-operation"><a href="#IO操作-IO-operation" class="headerlink" title="IO操作(IO operation)"></a>IO操作(IO operation)</h2><ul><li>特指通过系统调用(<code>recvfrom()</code>)<strong>请求从内核缓冲区拷贝数据到进程内存(copy data from kernel to user)</strong>, (<strong>不包括</strong>从设备缓冲区拷贝数据到内核缓冲区)</li><li>整个IO<strong>请求</strong>过程<ul><li>每个设备都有一个设备控制器(可以类比：每个计算机都有一个CPU，设备控制器是一个微型CPU)，设备控制器也有缓存，操作系统会通过每个设备控制器对应的驱动程序管理设备控制器进行硬件操作。</li><li>当线程发起关于IO操作的系统调用后，线程会阻塞，操作系统通过驱动程序控制设备控制器读取数据到设备控制器的缓存中，然后在将设备控制器缓存中的数据读取到操作系统内核缓冲区中，然后通过硬件中断唤醒被阻塞的线程进行后续操作。</li></ul></li></ul><h1 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h1><h2 id="阻塞IO-blocking-IO"><a href="#阻塞IO-blocking-IO" class="headerlink" title="阻塞IO(blocking IO)"></a>阻塞IO(blocking IO)</h2><ul><li><p>执行IO操作时，当内核缓冲区还没有准备好数据时，<strong>会阻塞</strong>当前线程，直到内核缓冲区中的数据拷贝到进程内存中才会使得线程从阻塞变为就绪状态。</p><p><img src="/img/in-post/post-network/blockingIO.png" alt="阻塞IO"></p></li></ul><h2 id="非阻塞IO-nonblocking-IO"><a href="#非阻塞IO-nonblocking-IO" class="headerlink" title="非阻塞IO(nonblocking IO)"></a>非阻塞IO(nonblocking IO)</h2><ul><li><p>在进行IO操作期间，当内核缓冲区中还没有准备好数据，<strong>不会阻塞</strong>当前线程，会直接返回。线程会一直进行系统调用检测内核中数据是否准备好，如果内核准备好数据以后，并且又收到了线程的IO请求，则会进行数据拷贝，拷贝期间会阻塞当前线程(<strong>这不是区分阻塞和非阻塞的因素，因为此时内核缓冲区中已经存在数据</strong>)。</p></li><li><p>在Linux下，通过设置socket为non-blocking，从而实现该模型。</p></li><li><p>非阻塞IO的特点就是不断地询问内核是否已经准备好数据。</p><p><img src="/img/in-post/post-network/nonblockingIO.png" alt="非阻塞IO"></p></li></ul><h2 id="IO多路复用-事件驱动IO、IO-multiplexing"><a href="#IO多路复用-事件驱动IO、IO-multiplexing" class="headerlink" title="IO多路复用(事件驱动IO、IO multiplexing)"></a>IO多路复用(事件驱动IO、IO multiplexing)</h2><ul><li><p>通过单个线程管理多个Socket文件描述符，当至少一个Socket文件描述符可用时就会返回可用文件描述符的<strong>数量</strong>(<code>select()</code>、<code>poll()</code>)或者具体可用的Socket(<code>epoll()</code>)。然后线程轮询找到可用的Socket文件描述符,通过IO操作读取数据到用户地址空间(这一步常常配合非阻塞IO,也就是将对Socket的操作改为非阻塞)</p></li><li><p>Linux下，IO多路复用的实现通过<code>select()</code>、<code>poll()</code>、<code>epoll()</code>实现。</p></li><li><p>当调用<code>select()</code>、<code>poll()</code>、<code>epoll()</code>后线程会阻塞，直到有可用的socket后内核会唤醒线程。然后线程通过轮询(<code>epoll()</code>除外)找到具体可用的socket，进行IO操作。</p><p><img src="/img/in-post/post-network/ioMultiplexing.png" alt="IO多路复用"></p></li></ul><h2 id="信号驱动IO-signal-driven-IO"><a href="#信号驱动IO-signal-driven-IO" class="headerlink" title="信号驱动IO(signal driven IO)"></a>信号驱动IO(signal driven IO)</h2><ul><li><p>应用进程使用<code>sigaction</code>系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达后向应用进程发送<strong>SIGIO</strong>信号，应用进程收到之后在信号处理程序中执行IO操作(调用<code>recvfrom()</code>将数据从内核复制到应用进程中)。</p><p><img src="/img/in-post/post-network/signoIO.png" alt="信号驱动IO">  </p></li></ul><h2 id="异步IO-asynchronous-IO"><a href="#异步IO-asynchronous-IO" class="headerlink" title="异步IO(asynchronous IO)"></a>异步IO(asynchronous IO)</h2><ul><li><p>线程发起<code>aio_read()</code>系统调用会立即返回,<strong>不会阻塞</strong>,而且<strong>可以去干其它的事情</strong>,内核会等待数据准备好,然后拷贝到进程地址空间,然后以回调的形式通知线程。</p><p><img src="/img/in-post/post-network/aio.png" alt="异步IO">  </p></li></ul><h2 id="几种模型汇总比较"><a href="#几种模型汇总比较" class="headerlink" title="几种模型汇总比较"></a>几种模型汇总比较</h2><ul><li><p>阻塞IO、非阻塞IO、IO多路复用和信号驱动式IO都是同步IO，在IO操作期间都会发生阻塞。主要区别在第一阶段(<strong>wait for data</strong>),非阻塞IO、IO多路复用、信号驱动式IO在第一阶段不会阻塞。</p><p><img src="/img/in-post/post-network/ioModelDifference.png" alt="异步IO">  </p></li></ul><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="阻塞IO、非阻塞IO区分条件？"><a href="#阻塞IO、非阻塞IO区分条件？" class="headerlink" title="阻塞IO、非阻塞IO区分条件？"></a>阻塞IO、非阻塞IO区分条件？</h2><ul><li>内核缓冲区中<strong>没有</strong>数据时，判断此时进行IO操作是否被阻塞  </li></ul><h2 id="同步IO与异步IO区别？"><a href="#同步IO与异步IO区别？" class="headerlink" title="同步IO与异步IO区别？"></a>同步IO与异步IO区别？</h2><ul><li>A synchronous I/O operation <strong>causes</strong> the requesting process to be blocked until that I/O operation completes;</li><li>An asynchronous I/O operation <strong>does not</strong> cause the requesting process to be blocked;</li></ul><h2 id="为什么IO多路复用需要搭配非阻塞IO？"><a href="#为什么IO多路复用需要搭配非阻塞IO？" class="headerlink" title="为什么IO多路复用需要搭配非阻塞IO？"></a>为什么IO多路复用需要搭配非阻塞IO？</h2><ul><li>比如当内核缓冲区准备好数据时,此时select()会返回,但是后续read()<strong>之前</strong>:内核检查该数据时,如果出现错误的校验和,就会丢弃该数据,当线程进行IO操作时就会阻塞,从而可能出现安全问题。man select里的一个BUG描述：<ul><li><strong>Under Linux, select() may report a socket file descriptor as “ready for reading”, while nevertheless a subsequent read blocks.  This could for example happen when       data has arrived but upon examination has wrong checksum and is discarded.  There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.</strong></li></ul></li></ul><h2 id="select-poll-epoll区别？"><a href="#select-poll-epoll区别？" class="headerlink" title="select/poll/epoll区别？"></a>select/poll/epoll区别？</h2><ul><li>select监听的文件描述符数量有限制(1024个),并且返回时只是返回的可用的Socket的数量,并不是具体哪个Socket可用,客户端还得需要轮询找出可用的Socket。</li><li>poll解除了文件描述符的数量,但也得轮询找出可用socket。</li><li>内核会修改select/poll传入的文件描述符集合，所以每次都需要拷贝文件描述符到内核，所以当socket数量比较多时，会影响效率。</li><li>epoll返回时会得到具体可用的Socket描述符,不用去轮询。</li><li>select相对于epoll来说是跨平台的，而epoll是针对于Linux的，Windows是使用IOCP实现，OS X使用kqueue实现的。</li><li>如果系统存在大量的空闲连接，那每次遍历文件描述符开销会很大，此时可以选用epoll，如果只有很少的连接，可以选用select。</li></ul><h2 id="select和epoll工作流程？"><a href="#select和epoll工作流程？" class="headerlink" title="select和epoll工作流程？"></a>select和epoll工作流程？</h2><p><a href="https://www.zhihu.com/question/20122137/answer/146866418" target="_blank" rel="noopener">参考自知乎</a></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>当客户端调用select以后，会挂起当前线程，此时内核会去检测select所监控的socket，当socket可读或者可写了，就会以<strong>中断</strong>的形式通知select，select就会返回可用的socket的数量，客户端遍历找到可用的socket。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll维护了一个红黑树用来存放监听的文件描述符,并且注册一个回调函数给内核，当内核发现红黑树上的Socket文件描述符对应的Socket可用时，会将该描述符放到就绪链表中。当内核检测到socket可用时，就会通过注册的回调函数将socket对应的文件描述符放到就绪链表中。epoll就会返回就绪链表。epoll处理文件描述符有两种工作模式，水平触发(level trigger)和边缘触发(edge trigger)</p><ul><li>水平触发是指当客户端不处理返回的socket时，就绪链表中不会删除这个socket对应的文件描述符，下次调用epoll_wait()时还会返回这个socket对应的文件描述符</li><li>边缘触发是指如果客户端不处理返回的socket时，就绪链表中不会保存这个socket对应的文件描述符，下次调用epoll_wait()就不会返回这个socket对应的文件描述符，直到有新的事件过来。</li></ul><p>总结就是，LT模式下，只要某个文件描述上的事件一次没有处理完，会在以后调用epoll_wait()时次次返回这个文件描述符，而ET模式仅在第一次返回，返回以后，会清除就绪链表</p><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO?"></a>Java NIO?</h2><ul><li>Java NIO(New IO)实现了非阻塞IO模型,并且通过Selector选择器实现了IO多路复用模型(Linux2.6之前使用的是select(),2.6之后是epoll(),默认边缘触发)</li><li>NIO可以实现零拷贝，使得数据直接在内核态进行拷贝，不用再进入用户态。  </li><li>NIO实现了非阻塞IO模型，并且搭配Selector来实现IO多路复用。  </li></ul><h2 id="BIO-NIO-AIO区别"><a href="#BIO-NIO-AIO区别" class="headerlink" title="BIO/NIO/AIO区别?"></a>BIO/NIO/AIO区别?</h2><ul><li>BIO是面向流的，而NIO是面向缓冲Buffer的。并且Buffer内部维护了三个指针(position、limit、capacity)可以操作，相对于BIO来说比较灵活。BIO中的流是分方向的（输入流、输出流）。而NIO中的Channel类似于BIO中的流，但是Channel没有方向，可以向Channel中读取数据和写入数据。  </li><li>AIO是异步IO</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html" target="_blank" rel="noopener">I/O Models</a></li><li><a href="https://segmentfault.com/a/1190000003063859#articleHeader5" target="_blank" rel="noopener">Linux IO模式及select、poll、epoll详解</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md" target="_blank" rel="noopener">Linux IO GitHub笔记</a></li><li><a href="https://book.douban.com/subject/1896753/" target="_blank" rel="noopener">CSAPP第十章、第十一章</a></li><li><a href="https://www.zhihu.com/question/37271342" target="_blank" rel="noopener">为什么IO多路复用要搭配非阻塞IO？</a></li><li><a href="http://www.jasongj.com/java/nio_reactor/" target="_blank" rel="noopener">Java NIO</a></li><li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">NIO BIO</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux网络IO模型分为同步和异步两种，其中同步IO又包括阻塞IO、非阻塞IO、IO多路复用、信号驱动式IO四种。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://github.jinshuai86.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://github.jinshuai86.io/tags/Linux/"/>
    
      <category term="IO" scheme="https://github.jinshuai86.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C源码阅读笔记（四）Lock</title>
    <link href="https://github.jinshuai86.io/2018/08/15/Lock/"/>
    <id>https://github.jinshuai86.io/2018/08/15/Lock/</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p><code>Lock</code>接口下的锁是基于AQS实现的显式锁。具体有<code>ReentrantLock</code>、<code>ReentrantReadWriteLock.ReadLock</code>、<code>ReentrantReadWriteLock.WriteLock</code>。相对于<code>synchronized</code>隐式锁，这些锁更灵活。</p><a id="more"></a><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>实现了Lock接口，是一个显示可重入锁，并且提供了公平锁和非公平锁的实现。</p><h2 id="非公平锁-new-ReentrantLock"><a href="#非公平锁-new-ReentrantLock" class="headerlink" title="非公平锁 new ReentrantLock();"></a>非公平锁 new ReentrantLock();</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p>非公平锁获取锁的过程:</p><ul><li>首先会尝试将锁状态<code>state</code>通过CAS<code>compareAndSetState(0, 1)</code>设置为独占模式(修改为1)   <ul><li>如果修改成功，将会调用<code>setExclusiveOwnerThread(Thread.currentThread())</code>将独占线程变量<code>exclusiveOwnerThread</code>指向当前线程  </li><li>如果修改失败，将会调用<code>acquire(1)</code>尝试重新获取锁。原因是可能当前线程之前通过<code>lock()</code>已经获取到锁了，现在又调用<code>lock()</code>,所以会失败，所以会判断独占锁的线程是否是当前线程。如果不是的话或者重试以后还是没有获取到锁就会将当前线程封装成一个队列节点放到阻塞队列中，挂起当前线程。  </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会再调用<code>tryAcquire(arg)</code>尝试通过CAS获取锁  </p><ul><li>如果获取成功，直接返回  </li><li>如果获取失败，就会调用<code>addWaiter(Node.EXCLUSIVE), arg)</code>创建队列节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程    </span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取锁状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果当前锁没有被锁定，就会尝试再次通过CAS获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果获取锁成功(通过CAS成功修改state为1)，设置当前线程为独占锁线程</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经获取锁的线程再次进入临界区，直接将锁状态加1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 整数溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置锁计数</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁失败，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将当前线程封装成队列节点，插入到队列尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个关于当前线程的节点Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 先通过CAS将当前节点放到队列尾部，如果失败，在执行死循环保证将该节点放到队列尾部</span></span><br><span class="line">    <span class="comment">// 优点是：如果成功放到队列尾部，就不用去执行死循环</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 获取队尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果队列已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置当前节点的前驱节点为目前队尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 通过CAS设置tail指向node</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 设置tail指向node成功以后，将原来的队尾节点(pred目前指向的节点)后继节点指向node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS设置失败，执行死循环保证将封装当前线程的节点放到队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS设置失败，执行死循环保证将封装当前线程的节点放到队列中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取队尾节点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果队列还没创建</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 创建一个虚假节点new Node()队头head和队尾tail都指向该节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        <span class="comment">// 队列已经存在：通过CAS将当前节点入队即可</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入到队列以后，根据当前线程节点的前驱节点状态<code>waitstatus</code>决定当前线程是否应该被阻塞 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 直到获取锁，才会跳出死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点：为了在锁定之前决定是否会再次去尝试获取锁...</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果当前节点的前驱节点是头节点，在锁定之前会再次去尝试获取锁...</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功以后将此节点设置为头节点(head = node;)，释放线程(node.thread = null;)</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 将之前的头节点next指针置空</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在挂起当前线程之前，还会再次判断当前线程是否应该阻塞(可能它前面的节点【都】已经取消了呢？(节点处于CANCELL状态)，此时就会返回false)</span></span><br><span class="line">            <span class="comment">// 如果应该阻塞当前线程，就会调用parkAndCheckInterrupt()阻塞当前线程并检查中断状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装当前线程的节点会根据它前驱节点的状态判断当前线程是否应该被阻塞  </p><ul><li>如果当前线程节点的前驱节点状态是SIGNAL(-1)，说明已经可以保证它的前驱节点在释放锁时唤醒它，所以当前线程可以安全的被阻塞了…</li><li>如果当前线程节点的前驱节点状态大于0，说明前驱节点封装的线程被取消了，应该从队列中移除，然后判断前驱节点的前驱节点…  直到找到状态为小于0的节点  </li><li>如果当前线程节点的前驱节点状态等于0，说明前驱节点里的线程已经被阻塞了，此时会将前驱节点的状态改为SIGNAL，然后返回true，代表应该阻塞当前线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// SIGNAL == -1</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 当前节点的前驱节点已经被取消了(失效了，可能已经为null)，需要重置当前节点的前驱节点。</span></span><br><span class="line">    <span class="comment">// 节点操作因为超时或者对应的线程被interrupt。节点不应该留在此状态，一旦达到此状态将从CHL队列中踢出。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// cancelled == 1 &gt; 0</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当head指向的是一个dummy节点时(当第一个节点插入到CLH队列中时)，ws为0。 需要修改dummy节点的waitstatus</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂起当前线程。当此线程被唤醒时判断线程的中断状态，如果线程被中断过，就通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>重新设置线程的中断状态  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h3><p>首先将锁计数<code>state</code>减1</p><ul><li>如果锁计数<code>state</code>为0了，则释放当前锁，唤醒头节点的下一节点中封装的线程</li><li>如果锁计数<code>state</code>不为0，则不释放当前锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 修改锁计数 2. 唤醒下一节点中封装的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改锁计数</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 可能当前线程第一个获取锁的线程，此时head并没有被初始化</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试释放：将state减1，根据state的值决定是否应该释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取释放掉锁以后的锁计数</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果锁计数为0，则释放当前线程持有的锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒下一节点中封装的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取头节点线程的等待状态为SIGNAL==-1，表示下一节点不用再阻塞</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 下一节点可能已经取消，所以如果下一节点取消的话，就需要找到一个有效的下一节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒下一节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><p>如果获取不到锁，直接返回<code>false</code>，不会阻塞当前线程。<br>在<code>tryLock()</code>中尝试获取一次锁，如果没有成功，就不会再去获取或者阻塞当前线程，而是返回<code>false</code><br>如果获取不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryLock-long-timeout-TimeUnit-unit"><a href="#tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="tryLock(long timeout, TimeUnit unit)"></a>tryLock(long timeout, TimeUnit unit)</h3><p>超时获取锁：在指定时间段内<code>timeout</code>会一直尝试获取锁，直到获取锁返回<code>true</code>，如果一直没有获取锁，超时以后会返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 先尝试获取一次，如果失败，再执行超时获取</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 将当前线程封装成节点添加到队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环中尝试多次获取。注意：如果获取不到，就会阻塞线程【指定】时间。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 如果超时，直接返回false，代表没有获取到锁</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果队列中有等待线程，此时应该阻塞当前线程【一段时间】</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h3><p>支持中断锁：如果一个线程在获取锁的过程中被中断了，会抛出InterruptedException。<br><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html" target="_blank" rel="noopener">Java Doc</a>：  </p><blockquote><p>If the current thread:<br>has its interrupted status set on entry to this method; or<br>is interrupted while <strong>acquiring</strong> the lock,<br>then InterruptedException is thrown and the current thread’s interrupted status is cleared.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前线程设置了中断，直接向上抛异常，并且清除中断状态，不会再去获取锁。</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 被阻塞的线程唤醒之后：如果检查到当前线程设置了中断，直接抛异常不会再去尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁-new-ReentrantLock-true"><a href="#公平锁-new-ReentrantLock-true" class="headerlink" title="公平锁 new ReentrantLock(true);"></a>公平锁 new ReentrantLock(true);</h2><h3 id="lock-1"><a href="#lock-1" class="headerlink" title="lock()"></a>lock()</h3><p>公平锁获取锁的过程:  </p><ul><li>首先会根据锁状态<code>state</code>来判断是否应该获取锁，而不是直接像非公平锁那样，<strong>直接</strong>尝试通过CAS<code>compareAndSetState(0, 1)</code>设置为独占模式(修改为1)来获取锁。  <ul><li>如果此时可以获取锁(<code>state</code>为0)，<strong>会进一步判断等待队列中是否存在等待获取锁的线程</strong>(和非公平锁的区别)<ul><li>如果此时队列中有等待线程，就会直接挂起当前线程。</li><li>如果此时队列中没有等待线程，就会尝试通过CAS<code>compareAndSetState(0, acquires)</code>去尝试获取锁。<ul><li>如果修改成功，将会调用<code>setExclusiveOwnerThread(Thread.currentThread())</code>将独占线程变量<code>exclusiveOwnerThread</code>指向当前线程</li><li>如果修改失败，将会调用<code>acquire(1)</code></li></ul></li></ul></li><li>如果此时不可以获取锁(<code>state</code>不为0)，直接挂起当前线程。  </li></ul></li></ul><blockquote><p>注意：公平锁和非公平锁都重写了<code>tryAcquire(int acquires)</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 判断锁状态，是否可以获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果此时可以获取锁，会进一步判断等待队列中是否有线程正在等待获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断此次是否是重入，如果重入，直接将锁计数加1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 即：不能获取锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断队列中是否还存在因为没有获取到锁而被阻塞的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 如果h.next == null，说明其它线程刚创建了一个dummy节点，还没入队，并且此时tail为null，head指向dummy节点</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="公平锁和非公平锁区别？"><a href="#公平锁和非公平锁区别？" class="headerlink" title="公平锁和非公平锁区别？"></a>公平锁和非公平锁区别？</h2><ul><li>处于非公平锁的线程直接尝试获取锁，不会去判断等待队列中是否已经有线程正在等待锁的释放。非公平锁会导致线程饥饿现象</li><li>处于公平锁模式的线程按照请求锁的顺序决定获取锁的顺序(加锁时会判断等待队列中是否<strong>已经有</strong>线程正在等待锁，如果有的话就不会再去获取锁而是插到队列尾部)。</li></ul><h2 id="ReentrantLock和synchronized的区别？"><a href="#ReentrantLock和synchronized的区别？" class="headerlink" title="ReentrantLock和synchronized的区别？"></a>ReentrantLock和synchronized的区别？</h2><ul><li>在用法上<ul><li>ReentrantLock需要显示的获取锁和释放锁。(注意：为了安全，需要在finally中释放锁)。而synchronized会自动地获取锁和释放锁</li><li>ReentrantLock通过Condition实现了唤醒线程和使当前线程睡眠的API，没有使用Object的API。</li><li>ReentrantLock只能修饰代码块，并不能修饰方法。而synchronized既可以修饰方法也可以修饰代码块</li></ul></li><li>在特性上<ul><li>ReentrantLock可以以非阻塞的形式来获取锁，如果没有获取锁，会返回false，而不会阻塞当前线程。 synchronized如果没有获取到锁，会阻塞当前线程</li><li>ReentrantLock可以以超时的形式来获取锁，如果在指定时间段内没有获取到锁，直接返回false，不会阻塞当前线程。</li><li>ReentrantLock实现了公平锁，防止了非公平锁可能产生的线程饥饿现象。</li><li>ReentrantLock实现了以中断形式来获取锁，如果线程在获取锁的过程中，被中断了，会直接抛出异常，不会再去尝试获取锁。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Lock&lt;/code&gt;接口下的锁是基于AQS实现的显式锁。具体有&lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock.ReadLock&lt;/code&gt;、&lt;code&gt;ReentrantReadWriteLock.WriteLock&lt;/code&gt;。相对于&lt;code&gt;synchronized&lt;/code&gt;隐式锁，这些锁更灵活。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JUC" scheme="https://github.jinshuai86.io/tags/JUC/"/>
    
      <category term="多线程" scheme="https://github.jinshuai86.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C源码阅读笔记（三）同步器</title>
    <link href="https://github.jinshuai86.io/2018/08/14/Synchronizer/"/>
    <id>https://github.jinshuai86.io/2018/08/14/Synchronizer/</id>
    <published>2018-08-13T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p>同步器用来协助线程同步，具体有 <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>、<code>Exchanger</code>。</p><a id="more"></a><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>通俗理解: <code>CountDownLatch</code>可以理解为是一扇门，门上有若干把锁，当线程到达这个门时，如果门上锁的数量不为0，就会阻塞当前线程，直到门上锁的数量减为0，此时会唤醒被阻塞的线程。并且门打开以后不会在关闭。<br>具体实现: <code>CountDownLatch</code>是基于<code>AQS</code>实现的，锁的数量就是<code>AQS</code>中的<code>state</code>，通过构造函数设置<code>state</code>初始值。当调用<code>CountDownLatch</code>的<code>await()</code>方法时，如果<code>state</code>不为0，就会阻塞当前线程。如果为0就不会阻塞。当通过<code>countDown()</code>将<code>state</code>减为0时，就会唤醒之前被阻塞的线程。并且<code>state</code>减为0后不会被重置。<br><code>CountDownLatch</code>可以理解为:所有线程需要等待某个事件发生以后，才能继续执行，否则就会被阻塞。</p><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="public-CountDownLatch-int-count"><a href="#public-CountDownLatch-int-count" class="headerlink" title="public CountDownLatch(int count)"></a>public CountDownLatch(int count)</h3><p>通过构造函数设置锁的初始数量，也就是<code>AQS</code>里的<code>state</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置AQS中的state，Sync继承了AQS</span></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-void-await"><a href="#public-void-await" class="headerlink" title="public void await()"></a>public void await()</h3><p>会判断<code>state</code>(锁)的数量是否为0，如果不为0就会被阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 获取共享模式下的锁，当state不为0时tryAcquireShared(arg)会返回-1 =&gt; 代表获取锁失败(具体到CountDownLatch，就是等待的事件没有发生)需要被阻塞。否则返回1</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当锁的数量(state)不为0时，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 将节点添加到队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 前驱节点为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取共享锁(判断锁的数量是否为0了)</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 如果锁的数量为0了，就会进这个if</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 设置当前节点为头节点，并且唤醒后继节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-void-countDown"><a href="#public-void-countDown" class="headerlink" title="public void countDown()"></a>public void countDown()</h3><p>释放锁(将state减1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断将state减1后是否为0，如果为0，则唤醒被阻塞的线程</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// h == null 代表还没有线程被阻塞，也就是说没有添加到阻塞队列里，所以不用唤醒</span></span><br><span class="line">        <span class="comment">// h == tail 代表state == 0了，但是又一个线程之前判断state不为0，正在创建head节点，</span></span><br><span class="line">        <span class="comment">// 也不用管(因为执行 int r = tryAcquireShared(arg); 时，state为0，所以就会返回)</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 因为释放了后继节点以后，后继节点对应线程执行setHeadAndPropagate(node, r)会修改head指针</span></span><br><span class="line">                <span class="comment">// 当前节点中的线程执行最后一个 if(h == head)时，可能后继节点中的线程已经修改了head， 判断false后当前节点中的线程就会重新循环</span></span><br><span class="line">                <span class="comment">// 所以当前节点对应的线程以及后继节点对应的线程同时走到这里后，并发修改head节点的waitstatus就可能会失败</span></span><br><span class="line">                <span class="comment">// 为什么要这样，不太清楚。有博客说是为了提高吞吐量。也就说当前线程唤醒了后继节点中的线程后，还可能会帮助唤醒其它节点中的线程</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒头节点head的后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点的waitStatus为0， 是因为之前只有当前节点被阻塞，当前节点修改时，有新的节点入队了，此时需要被唤醒，所以当前线程就会重新进入循环。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回false后，代表由当前节点对应线程唤醒的后继节点中的线程修改了head指针，导致返回false</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>统计多个线程并发执行某个任务所需要的时间。首先是要保证所有线程都处于就绪状态。也就是说线程需要等待【所有线程都处于就绪状态】这个事件发生。然后并发执行任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N); <span class="comment">// N代表N个线程</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    threadPool.submit(()-&gt;&#123;</span><br><span class="line">        startSignal.await(); <span class="comment">// 等待【所有线程就绪】事件发生</span></span><br><span class="line">        doTask();</span><br><span class="line">        doneSignal().countDown();</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">startSignal.countDown(); <span class="comment">// 此时所有线程已经就绪，然后触发【所有线程就绪】事件发生</span></span><br><span class="line">doneSignal().await(); <span class="comment">// 等待【所有线程执行完毕】这个事件发生</span></span><br><span class="line"><span class="keyword">long</span> total = System.currentTimeMillis(); - startTime; <span class="comment">// 统计时间</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p><code>CyclicBarrier</code>循环_栅栏(障碍物)。直到<strong>所有线程都</strong>到达以后，才会唤醒线程，否则提前到达的线程会被阻塞。当唤醒所有被阻塞的线程以后，会进入下一代，并且重置障碍，达到循环(Cyclic)的目的。<br><code>CyclicBarrier</code>可以理解为：等待所有线程都到达以后，被阻塞的线程才能继续执行。<br><code>CyclicBarrier</code>并没有直接依赖AQS实现，具体是通过<code>ReentrantLock</code>和<code>Condition</code>做的实现，因为要并发修改等待的线程数量。</p><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="public-CyclicBarrier-int-parties"><a href="#public-CyclicBarrier-int-parties" class="headerlink" title="public CyclicBarrier(int parties)"></a>public CyclicBarrier(int parties)</h3><p><code>parties</code>是需要等待的线程的数量，当等待的线程数量达到parties时，会唤醒这些等待的线程。<br><code>barrierAction</code>是当最后一个线程到达栅栏时，需要执行的操作。<br><code>count</code>是还需要等待几个线程，当需要等待的线程数量为0时，表示可以唤醒等待的线程  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-int-await"><a href="#public-int-await" class="headerlink" title="public int await()"></a>public int await()</h3><p>将需要等待的线程数量减1，当减到0时就会唤醒所有等待的线程。<br>等待所有的线程到达，如果当前线程不是最后一个到达的，将会被阻塞，直到最后一个线程到达后被唤醒。具体的执行逻辑在<code>dowait(boolean timed, long nanos)</code>里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前分代</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 判断当前分代是否由于超时、中断等被打破</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断还需要等待的线程的数量</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">// 如果需要等待的线程的数量为0，则表明当前线程是最后一个线程</span></span><br><span class="line">        <span class="comment">// 判断是否需要执行barrierCommand，然后唤醒等待的线程</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取注册的操作</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">// 如果操作不为null，则执行run()</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 进入下一分代，重置count</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 如果当前线程不是最后一个线程，将会被阻塞</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 没有设置超时等待，直接阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 设置了超时等待，则等待指定时间</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="comment">// 如果线程被中断了， 需要打破分代(设置Generation标志位)</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                <span class="comment">// 设置标志位、唤醒等待的线程</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当被唤醒的线程，发现分代被打破以后，直接抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            <span class="comment">// 当被唤醒的线程，发现当前分代不等于新的分代(最后一个线程会重新创建generation进入下一分代)。直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            <span class="comment">// 如果超时以后，直接打破分代、并且抛出超时异常。</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private-void-nextGeneration"><a href="#private-void-nextGeneration" class="headerlink" title="private void nextGeneration()"></a>private void nextGeneration()</h3><p>唤醒等待的线程，重置<code>count</code>，进入下一分代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="private-void-breakBarrier"><a href="#private-void-breakBarrier" class="headerlink" title="private void breakBarrier()"></a>private void breakBarrier()</h3><p>打破分代，重置<code>count</code>，并且唤醒其他线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>将大任务分解成若干个子任务。现在要统计一个矩阵所有元素相加和。可以让每一个线程求每一行。最后一个线程执行完以后，调用<code>await()</code>执行之前注册的barrierCommand将每一个线程的结果汇总。代码来自<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CyclicBarrier.html" target="_blank" rel="noopener">Oracle doc</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[][] data;</span><br><span class="line">    <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> myRow;</span><br><span class="line">        Worker(<span class="keyword">int</span> row) &#123; myRow = row; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!done()) &#123;</span><br><span class="line">                processRow(myRow);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solver</span><span class="params">(<span class="keyword">float</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        data = matrix;</span><br><span class="line">        N = matrix.length;</span><br><span class="line">        barrier = <span class="keyword">new</span> CyclicBarrier(N, () -&gt; &#123;mergeRows(...);&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以让固定数量的线程周期性的执行任务。比如周期性每次让10个线程并发执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(times, ()-&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"================"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p><img src="/img/in-post/post-java-juc/Semaphore.svg" alt="Semaphore"></p><ul><li><code>Semaphore</code>可以理解为是一个资源池，线程需要从这个资源池中申请到资源才能继续运行，否则会被阻塞直到资源池中有可用资源。</li><li><code>Semaphore</code>是基于AQS实现的，和<code>CountDownLatch</code>类似。<code>CountDownLatch</code>是当<code>state</code>为0时，需要唤醒线程。而它将AQS中的<code>state</code>表示为可用的资源数量，当<code>state</code>为0时代表没有可用资源，会将阻塞当前线程，将其添加到队列中，当其它线程释放资源后，此时<code>state</code>不为0，就会唤醒所有的被阻塞的线程。</li></ul><h2 id="部分源码分析-1"><a href="#部分源码分析-1" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="public-void-acquire-int-permits"><a href="#public-void-acquire-int-permits" class="headerlink" title="public void acquire(int permits)"></a>public void acquire(int permits)</h3><p>非公平信号量获取许可过程：通过<code>final int nonfairTryAcquireShared(int acquires)</code>获取state值，判断是否还有可用的许可。</p><ul><li>如果有的话直接返回</li><li>如果没有可用的许可，将当前线程封装到队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 传入的许可数量是负数，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 尝试获取许可</span></span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 判断可用的许可数量是否满足需要，如果不满足会将当前线程封装到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取可用的许可</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 判断可用许可数量是否满足需要</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 将节点添加到队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 前驱节点为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取共享锁(判断锁的数量是否为0了)</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 如果锁的数量为0了，就会进这个if</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 设置当前节点为头节点，并且唤醒后继节点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-void-release"><a href="#public-void-release" class="headerlink" title="public void release()"></a>public void release()</h3><p>释放许可操作：将状态变量<code>state</code>加1，并唤醒阻塞的线程。<strong>注意(Java Doc)：在释放许可时，不必提前获取许可</strong></p><blockquote><p><strong>There is no requirement that a thread that releases a permit must have acquired that permit by calling acquire.</strong> Correct usage of a semaphore is established by programming convention in the application.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放资源以后，唤醒之前被阻塞的所有线程，让它们竞争资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 参照CountDownLatch注释</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过CAS将state加1，因为释放操作是多个线程并发的。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当维护的许可数量是1时，就是互斥锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="控制线程提交的最大任务量"><a href="#控制线程提交的最大任务量" class="headerlink" title="控制线程提交的最大任务量"></a>控制线程提交的最大任务量</h3><p>比如爬虫程序中，控制线程提交的最大任务量，将许可数量设置为线程池中最大线程数量 <strong>+</strong> 任务队列长度来保证提交的任务都能被执行，防止提交任务过多导致内存溢出或者执行拒绝策略。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步器用来协助线程同步，具体有 &lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBarrier&lt;/code&gt;、&lt;code&gt;Semaphore&lt;/code&gt;、&lt;code&gt;Exchanger&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JUC" scheme="https://github.jinshuai86.io/tags/JUC/"/>
    
      <category term="多线程" scheme="https://github.jinshuai86.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C源码阅读笔记（二）并发容器</title>
    <link href="https://github.jinshuai86.io/2018/08/12/SynchronizedContainer/"/>
    <id>https://github.jinshuai86.io/2018/08/12/SynchronizedContainer/</id>
    <published>2018-08-11T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p>并发容器提供了线程安全的容器。比如线程安全的Map/Queue/List (<code>ConcurrentHashMap</code>、<code>BlockingQueue</code>、<code>CopyOnWriteArrayList</code>)，其它的还有阻塞队列，比如<code>ArrayBolckingQueue</code>、<code>LinkedBlockingQueue</code>、<code>DelayQueue</code>、<code>SynchronousQueue</code></p><a id="more"></a><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>ConcurrentHashMap</code>是一个线程安全的<code>Map</code></p><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="public-V-put-K-key-V-value"><a href="#public-V-put-K-key-V-value" class="headerlink" title="public V put(K key, V value)"></a>public V put(K key, V value)</h3><p>调用<code>putVal(K key, V value, boolean onlyIfAbsent)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><p>在插入的时候会对数据进行预判断，不允许<code>key</code>和<code>value</code>为<code>null</code>，否则抛空指针。<br>由于内部维护的数组<code>tab</code>是懒加载，当<code>tab</code>没初始化时，会将<code>tab</code>初始化。通过轮询由<code>volatile</code>修饰的变量来保证只能有一个线程初始化数组。<br>当哈希表正在进行扩容时，当前线程会尝试帮助扩容。因为在扩容时会将<code>ForwardingNode</code> 放到数组下标，而<code>ForwardingNode</code>的hash为MOVED。<br>插入以后会将记录键值对数量的值尝试用CAS加1，如果没有成功，就将这个变化值存到一个数组中。最终键值对的数量是记录键值对数量的值加上记录变化的数组中的值。<br>扩容时会将原哈希表中的键值对放到一个大小是原哈希表二倍的新的哈希表中。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 为了分布均匀对key的hashcode再hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 根据binCount通过计算链表长度，判断链表是否修改过，如果链表的数量超过设定的阈值，插入完成之后需要变成红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化tab，死循环直到插入成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    <span class="comment">// 指向目标节点</span></span><br><span class="line">        Node&lt;K,V&gt; f; </span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 延迟加载:如果没有初始化进行初始化，并且通过轮询volatile变量保证只有一个线程执行哈希表的初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 如果数组下标对应的元素为null，通过CAS放到当前数组下标处</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点的hash值为MOVED常量，则表示这个ConcurrentHashMap正在进行扩容</span></span><br><span class="line">        <span class="comment">// (在转移当前桶时，将将当前数组下表设置为ForwardingNode)</span></span><br><span class="line">        <span class="comment">// ForwardingNode的Hash等于MOVED: super(MOVED, null, null, null);</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">// 当前数组下标有元素，并且可以正常插入，则根据节点元素类型是红黑树节点还是链表节点然后执行插入</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 加锁，Monitor对象是当前数组下标元素持有的Monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">            <span class="comment">// tabAt(tab,i)会通过Unsafe类求出数组下标元素，再次判断确保是否是上面所确定的f</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                <span class="comment">// 代表是链表元素，执行插入链表操作</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果已经存在此key，则更新即可(此处为了性能，尽量不用equals()，所以显示比较是否指向同一个对象)</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 不存在，则插入到链表尾部</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前数组下标元素类型是红黑树,执行红黑树插入操作</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据binCount判断链表元素个数</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 超过阈值，则将链表变成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前维护的baseCount + 1，然后判断是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  下面两个函数来源: https://yfzhou.coding.me/2018/12/24/%E5%89%91%E6%8C%87ConcurrentHashMap%E3%80%90%E5%9F%BA%E4%BA%8EJDK1-8%E3%80%91/  */</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过一系列的判断，如果可以帮助扩容的话，最终会调用transfer(tab, nextTab);协助扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 如果 table 不是空 且 node 节点是转移类型，数据检验</span></span><br><span class="line">    <span class="comment">// 且 node 节点的 nextTable（新 table） 不是空，同样也是数据校验</span></span><br><span class="line">    <span class="comment">// 尝试帮助扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据 length 得到一个标识符号</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">// 如果 nextTab 没有被并发修改 且 tab 也没有被并发修改</span></span><br><span class="line">        <span class="comment">// 且 sizeCtl  &lt; 0 （说明还在扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 sizeCtl 无符号右移  16 不等于 rs （ sc前 16 位如果不等于标识符，则标识符变化了）</span></span><br><span class="line">            <span class="comment">// 或者 sizeCtl == rs + 1  （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></span><br><span class="line">            <span class="comment">// 或者 sizeCtl == rs + 65535  （如果达到最大帮助线程的数量，即 65535）</span></span><br><span class="line">            <span class="comment">// 或者转移下标正在调整 （扩容结束）</span></span><br><span class="line">            <span class="comment">// 结束循环，返回 table</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果以上都不是, 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 进行转移，将table指向的tab中的键值对重新放到nextTab中(nextTab容量是tab的二倍)，扩容完毕后，将table指向nextTab</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  从 putVal 传入的参数是 1， binCount，binCount 默认是0，只有 hash 冲突了才会大于 1.且他的大小是链表的长度（如果不是红黑数结构的话）。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 如果CounterCell不为null，就将这次变化的值放到CounterCell,否则尝试用CAS更新baseCount，如果更新失败，就将这次变化的值放到CountCell中</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">                U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// 如果CAS更新CounterCell失败，就会进入这个方法，保证最终更新成功</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容） 且</span></span><br><span class="line">        <span class="comment">// table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 根据 length 得到一个标识</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 sc 的低 16 位不等于标识符（校验异常 sizeCtl 变化了）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></span><br><span class="line">                <span class="comment">// 如果 sc == 标识符 + 65535（帮助线程数已经达到最大）</span></span><br><span class="line">                <span class="comment">// 如果 nextTable == null（结束扩容了）</span></span><br><span class="line">                <span class="comment">// 如果 transferIndex &lt;= 0 (转移状态变化了)</span></span><br><span class="line">                <span class="comment">// 结束循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 更新 sizeCtl 为负数后，开始扩容。</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h4><p>不允许<code>value</code>为<code>null</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K, V&gt; s;</span><br><span class="line">    <span class="comment">// 不允许value为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// UNSAFE通过hash找到Segment</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K, V&gt;) UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，如果加锁成功则执行后续操作，没有竞争到锁就需要自旋直到获取到锁并执行插入操作(自旋一定次数，就会调用阻塞锁)。</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 找到引用的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">// 求模计算数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">// 找到数组第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="comment">// 死循环，直到插入成功</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">// 数组对应下标已经存在数值。</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">// 已经存在此key，进行更新</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        <span class="comment">// 记录每一个Segment中的HashEntry数组中元素的数量</span></span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            <span class="comment">// 如果当前数组下标已经存在元素</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程可能自旋过（自旋过程可能会返回一个已经初始化的node），所以需要判断node是否为null</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-V-get-Object-key"><a href="#public-V-get-Object-key" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h3><h4 id="JDK8-1"><a href="#JDK8-1" class="headerlink" title="JDK8"></a>JDK8</h4><p>计算key对应的hash，然后通过hash定位到具体的桶，然后找到具体的value，因为value由<code>volatile</code>修饰，所以可以保证拿到的是最新的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; e, p; </span><br><span class="line">    <span class="keyword">int</span> n, eh; </span><br><span class="line">    K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在红黑树中查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 在链表中查找</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK7-1"><a href="#JDK7-1" class="headerlink" title="JDK7"></a>JDK7</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K, V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K, V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// 通过UNSAFE获取Segment，通过Segment获取HashEntry数组引用，进而找到指定的key</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K, V&gt;) UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp; (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K, V&gt; e = (HashEntry&lt;K, V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                (tab, ((<span class="keyword">long</span>) (((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-int-size"><a href="#public-int-size" class="headerlink" title="public int size()"></a>public int size()</h3><h4 id="JDK8-2"><a href="#JDK8-2" class="headerlink" title="JDK8"></a>JDK8</h4><p>通过由<code>volatile</code>修饰的<code>baseCount</code>变量以及<code>CounterCell</code>对象记录变化的次数求出size()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="comment">// 获取baseCount</span></span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历每一个CountCell中的value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK7-2"><a href="#JDK7-2" class="headerlink" title="JDK7"></a>JDK7</h4><p>通过计算Segment数组中每一个Segment中的modcount(在put时会++modCount)求出sum。但是不止求一次sum，会至少求两次（由<code>RETRIES_BEFORE_LOCK</code>决定的），如果两次求出的sum不一致，下次求就会将Segment数组全部加锁，重新求一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K, V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// 超出两次，将Segment全部加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K, V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取Segment对象的modCount</span></span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 和上一次求的结果比较</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="JDK8和JDK7的区别？"><a href="#JDK8和JDK7的区别？" class="headerlink" title="JDK8和JDK7的区别？"></a>JDK8和JDK7的区别？</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>JDK8存储结构采用Node类型数组加链表并通过拉链法解决hash冲突而JDK7基于AQS实现了一个Segment类继承自ReentrantLock，每个Segment对象持有一个HashEntry数组。Node和HashEntry都是实现了Map.Entry接口，只不过名字不同。</li></ul><h3 id="并发更新操作的实现"><a href="#并发更新操作的实现" class="headerlink" title="并发更新操作的实现"></a>并发更新操作的实现</h3><ul><li>JDK8通过synchronized+CAS机制进行并发更新，锁对象是数组下标对应的元素持有的Monitor。JDK7继承了AQS里的ReentrantLock进行加锁实现的并发更新。</li></ul><h3 id="计算size"><a href="#计算size" class="headerlink" title="计算size"></a>计算size</h3><ul><li>JDK8通过维护一个由volatile修饰的baseCount变量进行计数，以及一个CounterCell类进行记录变化的次数来确定size。JDK7采用延迟计算，在计算过程中会对每个Segment计算至少两次，如果出现数据不一致现象就进行全部加锁最后求得size。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://swenfang.github.io/2018/06/03/Java%208%20ConcurrentHashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">ConcurrentHashMap 源码解读</a></li><li><a href="https://yfzhou.coding.me/2018/12/24/%E5%89%91%E6%8C%87ConcurrentHashMap%E3%80%90%E5%9F%BA%E4%BA%8EJDK1-8%E3%80%91/" target="_blank" rel="noopener">剑指ConcurrentHashMap【基于JDK1.8】</a></li><li><a href="https://www.jianshu.com/p/e694f1e868ec" target="_blank" rel="noopener">谈谈ConcurrentHashMap1.7和1.8的不同实现</a></li><li><a href="http://penghb.com/2017/10/27/java/concurrentHashMap/" target="_blank" rel="noopener">ConcurrentHashMap源码分析(JDK1.8)</a></li><li><a href="http://www.importnew.com/26049.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></li></ul><hr><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><ul><li><code>BlockingQueue</code>接口下有<code>ArrayBolckingQueue</code>、<code>LinkedBlockingQueue</code>、<code>DelayQueue</code>、<code>SynchronousQueue</code>、<code>PriorityQueue</code>直接实现</li><li><code>BlockingDeque</code>接口继承自<code>BlockingQueue</code>下面有<code>LinkedBlockingDeque</code>实现</li></ul><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p><code>ArrayBlockingQueue</code>内部维护了一个<code>ReentrantLock</code>以及两个和<code>ReentrantLock</code>有关的<code>Condition</code>对象来实现阻塞操作。整体是一个循环队列(基于数组实现),并且队列的长度一旦设定就不可在变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="部分源码分析-1"><a href="#部分源码分析-1" class="headerlink" title="部分源码分析"></a>部分源码分析</h3><p>下面说的非阻塞/阻塞操作都是指<strong>已经获取锁后的操作</strong></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><code>final Object[] items; // 存放元素的数组</code>  </li><li><code>int takeIndex; // 队头元素位置</code>   </li><li><code>int putIndex; // 队尾元素位置</code>  </li><li><code>int count; // 队列长度</code>  </li></ul><h4 id="public-ArrayBlockingQueue-int-capacity"><a href="#public-ArrayBlockingQueue-int-capacity" class="headerlink" title="public ArrayBlockingQueue(int capacity)"></a>public ArrayBlockingQueue(int capacity)</h4><p>构造函数必须指定容量，并且容量后期不可扩充，如果队列满了以后会直接阻塞当前线程  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h4><p>非阻塞的入队方法，如果返回<code>false</code>则代表添加失败，父类会调用子类的<code>offer(e)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列不允许添加null，如果添加null直接抛出异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 否则入队，返回true代表入队成功</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">// 将入队元素放在入队位置</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">// 如果入完队以后队列已经满了，则将putIndex放到初始位置0</span></span><br><span class="line">    <span class="comment">// 因为用了一个冗余变量count来记录队列中元素的数量，所以不必再空一个元素来判断队列满或者队列空</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 增加队列数量</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 唤醒因为出队时队列没有元素而被阻塞的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-boolean-offer-E-e-long-timeout-TimeUnit-unit"><a href="#public-boolean-offer-E-e-long-timeout-TimeUnit-unit" class="headerlink" title="public boolean offer(E e, long timeout, TimeUnit unit)"></a>public boolean offer(E e, long timeout, TimeUnit unit)</h4><p>如果当前队列已经满了，则等待<code>timeout</code>，单位是<code>unit</code>，超时以后如果当前队列还是满的，则返回<code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 提前判空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 将超时时间换成纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列长度</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="comment">// 超时以后，如果当前队列还是满的，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 阻塞当前线程nanos时间</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-boolean-offer-E-e"><a href="#public-boolean-offer-E-e" class="headerlink" title="public boolean offer(E e)"></a>public boolean offer(E e)</h4><p>以阻塞的形式入队，如果当前队列已满则阻塞当前线程，并且采用可中断锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 提前判空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，则阻塞当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 否则入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="public-E-poll"><a href="#public-E-poll" class="headerlink" title="public E poll()"></a>public E poll()</h4><p>非阻塞的出队操作，如果当前队列长度为0则返回<code>false</code>，否则返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 获取要出队的元素</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">// 将出对元素的值设为null</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 实现循环队列</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 修改队列长度</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="comment">// 迭代器相关操作</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">// 唤醒当队列满时，因为入队操作而被阻塞的线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="comment">// 返回出队元素</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-E-take-throws-InterruptedException"><a href="#public-E-take-throws-InterruptedException" class="headerlink" title="public E take() throws InterruptedException"></a>public E take() throws InterruptedException</h4><p>以阻塞形式出队，如果当前队列长度为0，则阻塞当前线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列长度为0，阻塞当前线程</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 队列中存在元素，正常出队</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-E-poll-long-timeout-TimeUnit-unit-throws-InterruptedException"><a href="#public-E-poll-long-timeout-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="public E poll(long timeout, TimeUnit unit) throws InterruptedException"></a>public E poll(long timeout, TimeUnit unit) throws InterruptedException</h4><p>以超时的形式出队，如果当前队列长度为0，则阻塞当前线程一段时间，超时以后如果当前队列仍然没有元素，则返回false，否则正常出队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-E-peek"><a href="#public-E-peek" class="headerlink" title="public E peek()"></a>public E peek()</h4><p>获取队头元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-int-size-1"><a href="#public-int-size-1" class="headerlink" title="public int size()"></a>public int size()</h4><p>获取队列中的元素数量，获取数量前加锁，保证获取到的数量是最新的</p><blockquote><p>个人认为：去掉lock，用volatile修饰count也可以获取最新的正确的元素数量，因为每次对count的修改最多只是<strong>一个</strong>线程。去掉lock以后，保证每次读取count是最新的即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-int-remainingCapacity"><a href="#public-int-remainingCapacity" class="headerlink" title="public int remainingCapacity()"></a>public int remainingCapacity()</h4><p>获取队列的剩余空间(还可以存放多少元素)，<strong>不能通过判断剩余空间数量来决定是否插入，因为判断 -&gt; 插入是非原子操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列中数组的长度 - 队列中的元素数量</span></span><br><span class="line">        <span class="keyword">return</span> items.length - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="public-boolean-remove-Object-o"><a href="#public-boolean-remove-Object-o" class="headerlink" title="public boolean remove(Object o)"></a>public boolean remove(Object o)</h4><p>移除队列中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 预判断队列中的元素数量</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取下一个要插入元素的位置</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="comment">// 获取队头元素位置</span></span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 找到目标元素</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                    <span class="comment">// 移除队列中下标为i的元素</span></span><br><span class="line">                    removeAt(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保证循环</span></span><br><span class="line">                <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (i != putIndex); <span class="comment">// 到达队尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><code>CopyOnWriteArrayList</code>是一个线程安全的<code>List</code>,顾名思义，<strong>写时复制</strong>。当对数组做修改操作时，会加锁。比如添加元素时，会先将原数组元素拷贝到一个新的更大的数组中，将元素添加到新数组中，然后将原数组引用指向新数组。又因为数组由<code>volatile</code>修饰，所以对原数组引用的修改对其它线程是可见的。相对于<code>Vector</code>效率更高。</p><h2 id="部分源码分析-2"><a href="#部分源码分析-2" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h2 id="public-boolean-add-E-e-1"><a href="#public-boolean-add-E-e-1" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h2><p>当添加元素时，需要加锁保证线程安全，修改完以后将原数组引用指向新数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 修改之前先获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取原数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 将原数组元素复制到更大的新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 向新数组中添加元素</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将原数组引用指向新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-E-set-int-index-E-element"><a href="#public-E-set-int-index-E-element" class="headerlink" title="public E set(int index, E element)"></a>public E set(int index, E element)</h2><p>修改指定下标的元素。当修改元素时，需要加锁保证线程安全。修改完以后将原数组引用指向新数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取要修改的元素</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="comment">// 如果要修改的元素和预期元素值不同 =&gt; 正常修改</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        <span class="comment">// 如果要修改的元素的值和预期元素相同 =&gt; 保持不动即可：将原数组引用指向原数组。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-E-get-int-index"><a href="#public-E-get-int-index" class="headerlink" title="public E get(int index)"></a>public E get(int index)</h2><p>获取指定下标的元素。因为数组由<code>volatile</code>修饰，所以保证其它线程访问数组时都是最新的。  </p><p><code>private transient volatile Object[] array;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public-E-remove-int-index"><a href="#public-E-remove-int-index" class="headerlink" title="public E remove(int index)"></a>public E remove(int index)</h2><p>删除指定下标的元素。先获取锁。分删除最后一个元素还是中间元素。当删除最后一个元素，将原数组的将n-1个元素拷贝到新数组中，然后将原数组引用指向新数组即可。当删除的是中间元素。分别将原数组中间元素的左侧元素和右侧元素拷贝到新数组。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 删除的是最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 删除的元素是中间元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 将要删除元素左侧元素放到新数组中的左侧</span></span><br><span class="line">            <span class="comment">// 第二个参数是从原数组的起始位置开始拷贝，第三个是从新数组的起始位置开始放，第四个是要拷贝的元素长度</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 将要删除元素右侧元素放到新数组的右侧</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="CopyOnWriteArrayList-和-Vector区别？"><a href="#CopyOnWriteArrayList-和-Vector区别？" class="headerlink" title="CopyOnWriteArrayList 和 Vector区别？"></a>CopyOnWriteArrayList 和 Vector区别？</h2><p>Vector是对每个方法加锁，导致并发效率低，而COWL只对修改操作进行了加锁操作，只读操作并没有加锁。<strong>很适合读多写少的应用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发容器提供了线程安全的容器。比如线程安全的Map/Queue/List (&lt;code&gt;ConcurrentHashMap&lt;/code&gt;、&lt;code&gt;BlockingQueue&lt;/code&gt;、&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;)，其它的还有阻塞队列，比如&lt;code&gt;ArrayBolckingQueue&lt;/code&gt;、&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;、&lt;code&gt;DelayQueue&lt;/code&gt;、&lt;code&gt;SynchronousQueue&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JUC" scheme="https://github.jinshuai86.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C源码阅读笔记（一）AQS</title>
    <link href="https://github.jinshuai86.io/2018/08/11/aqs/"/>
    <id>https://github.jinshuai86.io/2018/08/11/aqs/</id>
    <published>2018-08-10T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p>AQS(<code>AbstractQueuedSynchronizer</code>)这个类提供了一个框架用来实现阻塞锁和一些同步工具类。比如<code>ReentrantLock</code>、<code>ReadWriteLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>等。 </p><a id="more"></a><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个类通过维护一个<code>volatile</code>修饰的变量<code>state</code>表示锁的获取情况以及一个FIFO队列用来封装要阻塞的线程。<br>线程通过CAS来修改<code>state</code>来获取锁，如果获取失败，会将当前线程封装成队列节点入队或者返回失败(<code>tryLock()</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(synchronization state does not allow acquire)&#123;</span><br><span class="line"></span><br><span class="line">    enqueue current thread <span class="keyword">if</span> not already queued;</span><br><span class="line"></span><br><span class="line">    possibly block current thread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列中的每个节点都封装了一个没有获取到锁而被阻塞的线程，队列中的节点有多种状态,比如SIGNAL代表当前节点的后继节点被阻塞了，当释放锁时需要唤醒后继节点中的线程。<code>CANCELLED</code>表示当前节点中的线程超时或者被中断了，此时就会将节点的<code>waitStatus</code>改为<code>CANCELLED</code>。保证出队和入队线程安全用的锁是CLH锁，CLH是一种基于链表的高性能自旋锁。作者介绍说CLH锁相对于MCS锁比较容易处理节点的超时和取消状态。并且出队和入队由于没有锁操作,效率会更高一些。</p><blockquote><p>However, they appeared more amenable than MCS for use in the synchronizer framework <strong>because they are more easily adapted to handle cancellation and timeouts, so were chosen as a basis.</strong></p></blockquote><blockquote><p>Among the advantages of <strong>CLH locks are that enqueuing and dequeuing are fast, lock-free, and obstruction free</strong> (even under contention, one thread will always win an insertion race so will make progress); that detecting whether any threads are waiting is also fast (just check if head is the same as tail); and that release status is decentralized, avoiding some memory contention</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Status field, taking on only the values:</span><br><span class="line">*   SIGNAL:     The successor of this node is (or will soon be)</span><br><span class="line">*               blocked (via park), so the current node must</span><br><span class="line">*               unpark its successor when it releases or</span><br><span class="line">*               cancels. To avoid races, acquire methods must</span><br><span class="line">*               first indicate they need a signal,</span><br><span class="line">*               then retry the atomic acquire, and then,</span><br><span class="line">*               on failure, block.</span><br><span class="line">*   CANCELLED:  This node is cancelled due to timeout or interrupt.</span><br><span class="line">*               Nodes never leave this state. In particular,</span><br><span class="line">*               a thread with cancelled node never again blocks.</span><br><span class="line">*   CONDITION:  This node is currently on a condition queue.</span><br><span class="line">*               It will not be used as a sync queue node</span><br><span class="line">*               until transferred, at which time the status</span><br><span class="line">*               will be set to 0. (Use of this value here has</span><br><span class="line">*               nothing to do with the other uses of the</span><br><span class="line">*               field, but simplifies mechanics.)</span><br><span class="line">*   PROPAGATE:  A releaseShared should be propagated to other</span><br><span class="line">*               nodes. This is set (for head node only) in</span><br><span class="line">*               doReleaseShared to ensure propagation</span><br><span class="line">*               continues, even if other operations have</span><br><span class="line">*               since intervened.</span><br><span class="line">*   0:          None of the above</span><br><span class="line">*</span><br><span class="line">* The values are arranged numerically to simplify use.</span><br><span class="line">* Non-negative values mean that a node doesn't need to</span><br><span class="line">* signal. So, most code doesn't need to check for particular</span><br><span class="line">* values, just for sign.</span><br><span class="line">*</span><br><span class="line">* The field is initialized to 0 for normal sync nodes, and</span><br><span class="line">* CONDITION for condition nodes.  It is modified using CAS</span><br><span class="line">* (or when possible, unconditional volatile writes).</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html</a></li><li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li><li><a href="http://www.blogjava.net/xylz/archive/2010/07/06/325390.html" target="_blank" rel="noopener">http://www.blogjava.net/xylz/archive/2010/07/06/325390.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AQS(&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;)这个类提供了一个框架用来实现阻塞锁和一些同步工具类。比如&lt;code&gt;ReentrantLock&lt;/code&gt;、&lt;code&gt;ReadWriteLock&lt;/code&gt;、&lt;code&gt;Semaphore&lt;/code&gt;、&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBarrier&lt;/code&gt;等。 &lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JUC" scheme="https://github.jinshuai86.io/tags/JUC/"/>
    
      <category term="多线程" scheme="https://github.jinshuai86.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C源码阅读笔记（零）java.util.concurrent</title>
    <link href="https://github.jinshuai86.io/2018/08/10/juc/"/>
    <id>https://github.jinshuai86.io/2018/08/10/juc/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.concurrent</code>是自JDK1.5提供的一个并发工具包。</p><a id="more"></a><p>J.U.C 框架包含的内容有(<strong><a href="https://www.zfl9.com/java-juc-framework.html" target="_blank" rel="noopener">以下内容转自这里!!!</a></strong>)：</p><ul><li>Executor 框架（线程池、Callable、Future），任务的执行和调度框架；</li><li>AbstractQueuedSynchronizer（AQS框架），J.U.C 中实现锁和同步机制的基础；</li><li>Locks &amp; Condition（锁和条件变量），比 synchronized、wait、notify 更细粒度的锁机制；</li><li>Synchronizers（同步器），主要用于协助线程同步，有 CountDownLatch、CyclicBarrier、Semaphore、Exchanger；</li><li>Atomic Variables（原子变量），方便程序员在多线程环境下，无锁的进行原子操作，核心操作是 CAS 原子操作，所谓的 CAS 操作，即 compare and swap，指的是将预期值与当前变量的值比较(compare)，如果相等则使用新值替换(swap)当前变量，否则不作操作；</li><li>BlockingQueue（阻塞队列），阻塞队列提供了可阻塞的入队和出对操作，如果队列满了，入队操作将阻塞直到有空间可用，如果队列空了，出队操作将阻塞直到有元素可用；</li><li>Concurrent Collections（并发容器），说到并发容器，不得不提同步容器，在 JDK1.5 之前，为了线程安全，我们一般都是使用同步容器，同步容器主要的缺点是：对所有容器状态的访问都串行化，严重降低了并发性；某些复合操作，仍然需要加锁来保护；迭代期间，若其它线程并发修改该容器，会抛出 ConcurrentModificationException 异常，即快速失败机制；</li><li>Fork/Join 并行计算框架，这块内容是在 JDK1.7 中引入的，可以方便利用多核平台的计算能力，简化并行程序的编写，开发人员仅需关注如何划分任务和组合中间结果；框架的核心是 ForkJoinPool 类，实现了工作窃取算法（对那些处理完自身任务的线程，会从其它线程窃取任务执行）并且能够执行 ForkJoinTask 任务；</li><li>TimeUnit 枚举，TimeUnit 是 java.util.concurrent 包下面的一个枚举类，TimeUnit 提供了可读性更好的线程暂停操作，以及方便的时间单位转换方法；  </li></ul><p>整个架构如下(<strong><a href="http://www.blogjava.net/xylz/archive/2010/06/30/324915.html" target="_blank" rel="noopener">下图转自这里!!!</a></strong>)：</p><p><img src="/img/in-post/post-java-juc/JUCFramework.png" alt="JUCFramework"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html</a></li><li><a href="http://www.blogjava.net/xylz/archive/2010/06/30/324915.html" target="_blank" rel="noopener">http://www.blogjava.net/xylz/archive/2010/06/30/324915.html</a></li><li><a href="https://www.zfl9.com/java-juc-framework.html" target="_blank" rel="noopener">https://www.zfl9.com/java-juc-framework.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt;是自JDK1.5提供的一个并发工具包。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JUC" scheme="https://github.jinshuai86.io/tags/JUC/"/>
    
      <category term="多线程" scheme="https://github.jinshuai86.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>缓存实现思路</title>
    <link href="https://github.jinshuai86.io/2018/08/06/MyCache/"/>
    <id>https://github.jinshuai86.io/2018/08/06/MyCache/</id>
    <published>2018-08-05T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p>缓存主要为了解决各个组件之间读取速度不匹配问题，比如寄存器是L1的缓存，L1是L2的缓存，L2是L3的缓存，L3是内存的缓存等。通过读Java Concurrency Practice P85，实现了一个简单可以添加和获取数据的缓存。其它的诸如缓存过期，更新缓存等没有实现- -!!  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><blockquote><p>计算接口，用到了装饰者模式。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">compute</span><span class="params">(A arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一种计算的实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">String</span>,<span class="title">BigInteger</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">compute</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 经过长时间计算后</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(arg); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h1><blockquote><p>通过HashMap时间复杂度为O(1)的特性以及synchronized保证线程安全来构建缓存</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheV1</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;A,V&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCacheV1</span><span class="params">(Computable computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> </span>&#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = (V)computable.compute(arg);</span><br><span class="line">            cache.put(arg,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h1><blockquote><p><strong>版本1</strong>添加了synchronized，多线程情况下造成性能下降 -&gt; 换成ConcurrentHashMap</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheV2</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;A,V&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCacheV2</span><span class="params">(Computable computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> </span>&#123;</span><br><span class="line">        V result = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = (V)computable.compute(arg);</span><br><span class="line">            cache.put(arg,result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h1><blockquote><p><strong>版本2</strong>先判断 -&gt; 在计算属于复合操作而且没有加锁导致线程不安全会产生重读计算。如果遇到计算时间非常长的计算，一旦重复会消耗大量的资源。<br>解决思路：如果其他线程正在计算目标值，当前线程阻塞直到其它线程计算出结果返回即可。<br>实现：通过FutureTask的get()方法。如果没有结果，会阻塞当前线程。  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheV3</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;A,FutureTask&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Computable computable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCacheV3</span><span class="params">(Computable computable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.computable = computable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(A arg)</span> </span>&#123;</span><br><span class="line">        Future future = cache.get(arg);</span><br><span class="line">        <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">            FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> (V)computable.compute(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 用到了ConcurrentHashMap的原子操作</span></span><br><span class="line">            future = cache.putIfAbsent(arg,futureTask);</span><br><span class="line">            <span class="comment">// 二次判断</span></span><br><span class="line">            <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;future = futureTask; futureTask.run();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (V) future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缓存主要为了解决各个组件之间读取速度不匹配问题，比如寄存器是L1的缓存，L1是L2的缓存，L2是L3的缓存，L3是内存的缓存等。通过读Java Concurrency Practice P85，实现了一个简单可以添加和获取数据的缓存。其它的诸如缓存过期，更新缓存等没有实现-
      
    
    </summary>
    
      <category term="Cache" scheme="https://github.jinshuai86.io/categories/Cache/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="设计" scheme="https://github.jinshuai86.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java容器框架源码阅读笔记（四）Map</title>
    <link href="https://github.jinshuai86.io/2018/07/23/Map/"/>
    <id>https://github.jinshuai86.io/2018/07/23/Map/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.Map</code>框架：<br><img src="/img/in-post/post-java-collection/Map.svg" alt="Map接口"></p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li>红黑树是一种特殊的二叉查找树，由平衡二叉查找树进化而来(在AVL中，保持全树的平衡开销太大)，红黑树只是保持局部平衡，即从每个节点向下直到叶子节点的路径中包含的黑色节点数量相同，达到一种”弱平衡”。它可以在 <strong>logn</strong> 时间内做查找，插入和删除，n是树中节点的数目。特性:  <ul><li><strong>根</strong>节点是黑色</li><li>从<strong>任一节点</strong>到其每个<strong>叶子节点</strong>的所有简单路径都包含相同数目的<strong>黑色节点</strong></li><li>叶子节点是不放数据的<strong>黑色节点</strong></li><li><strong>红色节点</strong>不能连续(红色节点的孩子和父亲节点颜色都不能是红色)</li></ul></li></ul><p><img src="/img/in-post/post-java-collection/Red-black_tree.png" alt="红黑树wiki"></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li>继承自<code>AbstractMap</code>，实现了<code>Cloneable</code>接口但是是<strong>浅</strong>拷贝，实现了<code>Seriable</code>可以进行序列化，实现了<code>Map</code>。  </li><li>基于数组(<code>Node</code>) + 链表(<code>Node</code>) + 红黑树(<code>TreeNode</code>)实现，当链表长度达到8时，链表会变为红黑树。在<code>resize()</code>对红黑树进行切割<code>split()</code>时，如果切割后的红黑树大小减少到6就变回链表。</li><li>非线程安全，如果需要线程安全需要使用<code>ConcurrentHashMap</code>、<code>Collections.synchronizedMap(new HashMap())</code>、<del><code>HashTable</code></del></li><li>可以存一个null key，数组下标默认是0，之后的null key会覆盖原来的。</li><li>数据不保证有序（放进去的顺序和拿出来的顺序不一样），如果需要有序可以使用<code>TreeMap</code>、<code>LinkedHashMap</code></li><li>数组长度是<strong>2的幂</strong>,初始是16,最大值是32。</li><li>数组长度是2的幂,这样可以通过位操作(&amp;)代替%提高计算效率，数组.length – 1 使得低位数字全为1 使得 &amp; 数组.length – 1得到的分布比不是2的幂的情况要均匀。  </li><li>通过用key的<code>hashcode()</code>再次求hash然后通过位运算得出要存的数组下标。</li><li>默认加载因子是0.75,当数组中元素的数量<strong>超过</strong>数组长度的0.75倍会进行扩容。</li><li>通过拉链法解决hash冲突，除此之外解决hash冲突的方法还有<strong>开放地址法(再散列法)、再哈希法、建立公共溢出区</strong>。</li></ol><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量/常量"></a>变量/常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组默认容量，2^4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组最大容量 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认负载因子，如果没指定负载因子，就会用这个默认的。通过负载因子来确定阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表树化阈值，当链表长度达到8就会变为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树链化阈值，在resize()时，会对红黑树进行分割split(),如果分割后的红黑树元素个数减少到6就会变为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在变红黑树时，还会判断数组的【长度】是否大于64，如果小于64则直接进行扩容resize()，不会变为红黑树。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出的阈值，当键值对的数量大于该阈值后，就会进行resize()扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以接收指定的负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h3 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据key获取value   </span></span><br><span class="line"><span class="comment"> * */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 基本思路:  </span></span><br><span class="line"><span class="comment"> * 根据提前计算好的hash =&gt;   </span></span><br><span class="line"><span class="comment"> * 计算数组下标(hash &amp; (tab.length - 1)) =&gt;   </span></span><br><span class="line"><span class="comment"> * 判断下标元素是否是查找的节点 =&gt;   </span></span><br><span class="line"><span class="comment"> *    是：直接返回节点  </span></span><br><span class="line"><span class="comment"> *    不是:继续在红黑树 || 单链表中查找  </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 预判断:数组是否为null，数组长度是否为0，求出的下标对应的元素是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 求出的下标对应的数组元素就是要获取的目标节点(如果两个key相同，那么hash肯定相同，所在先比较的hash。再就是先判断两个key是否指向同一个对象，如果指向同一个对象，就不用再执行耗时的equals操作)</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 求出的下标对应的数组元素不是要获取的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 从单链表中查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 将key，value插入到HashMap中</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 基本思路:  </span></span><br><span class="line"><span class="comment"> * 根据提前计算的hash =&gt;  </span></span><br><span class="line"><span class="comment"> * 计算要插入的数组下标(hash &amp; (tab.length - 1)) =&gt;  </span></span><br><span class="line"><span class="comment"> * 根据是链表还是红黑树插入目标节点  </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    <span class="comment">// 指向数组下标为 "hash与数组长度取模后((n - 1) &amp; hash)" 的元素</span></span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="comment">// n是数组长度，i是元素要插入的下标((n - 1) &amp; hash)</span></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果数组为null，代表数组还没有初始化。需要执行resize()初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果求出的数组下标对应的元素为null，代表该下标还没有元素，则直接在该下标添加元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果求出的数组下标已经存在元素，判断是红黑树还是链表</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到HashMap中该key对应的元素，然后让e指向该元素。当然也可能不存在该key对应的元素，从而找不到，使得e为null。  </span></span><br><span class="line">        <span class="comment">// 后续通过判断e是否为null来决定此次put是更新操作还是插入操作。  </span></span><br><span class="line">        <span class="comment">// 如果e为null，说明HashMap中并不存在key对应的元素，直接执行的插入操作  </span></span><br><span class="line">        <span class="comment">// 如果e不为null，说明HashMap中存在该key对应的元素，并且让e指向了该元素，需要执行更新操作，更新key对应元素的value。  </span></span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 如果是求出的数组下标的元素key和hash与新传进来的key和hash相同(传过来的key已经存在于数组中)</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 注意此时并没有更新节点值，只是将e指向该节点(此时e不为null)，最后会判断e是否为null，决定是否更新。</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果数组元素类型是红黑树 =&gt; 将新节点插入/更新到红黑树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组元素是单链表，进行尾插</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到表尾</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 插入元素后，如果当前链表长度 &gt; 7 则调用treefyBin() "决定是否" 变红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 因为binCount 从0开始，当binCount等于7时，代表链表长度为8。</span></span><br><span class="line">                        <span class="comment">// 将链表改为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 尾插过程中，如果已经存在此key，将e指向此key，退出。后面进行更新旧值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是已经存在的key，上面的遍历过程只是找到key对应的节点，并没有更新值</span></span><br><span class="line">        <span class="comment">// 最后需要更新节点旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录修改次数，fail-fast机制要用到</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果元素(键值对)数量大于阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// LinkedHashMap通过重写它，执行后续的操作：将这个节点添加到双向链表尾部。</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 还会进一步判断数组长度是否小于MIN_TREEIFY_CAPACITY，来决定是否变红黑树</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 如果数组长度比较小就直接扩容（小于变红黑树的阈值），不用变成红黑树。</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 将该位置对应的链表变为红黑树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-V-remove-Object-key"><a href="#public-V-remove-Object-key" class="headerlink" title="public V remove(Object key)"></a>public V remove(Object key)</h3><p>删除key对应的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指向原数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 指向求出的数组下标对应的元素</span></span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="comment">// n为数组长度，index为通过key求出的下标</span></span><br><span class="line">    <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 判断边界条件：数组是否为null、数组长度是否为0、下标对应的元素是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// node最终指向要删除的节点</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; </span><br><span class="line">        K k; V v;</span><br><span class="line">        <span class="comment">// 判断下标对应的元素是否就是要删除的元素，如果是，直接将node指向这个元素</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="comment">// 如果不是的话，要删除的元素可能在红黑树里或者在单链表中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果在数组下标元素类型是红黑树节点类型就在红黑树中查找欲删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果数组下标元素类型是单链表节点类型就在链表中查找欲删除的节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除node指向的节点(因为执行了上面的代码，如果欲删除的元素在map中，此时node已经指向欲删除的元素)</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果要删除的节点类型是红黑树，就执行红黑树删除节点的api</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 如果要删除的节点类型是单链表，就执行单链表删除节点操作，下面的p此时是node的前置节点(因为在遍历单链表时，p一直在node前面)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 添加修改次数</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 键值对数量减1</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 执行完删除节点操作以后，会执行LinkedHashMap重写的这个方法(实际上就是执行双向链表的删除节点的操作，因为LinkedHashMap里的是双向链表)</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">// 返回删除的节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 2倍扩容数组长度  </span></span><br><span class="line"><span class="comment"> * */</span>  </span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果当前数组存在元素：不是新创建的</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前数组长度大于等于允许的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 阈值就变成无穷大</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前数组长度没有超过最大长度，二倍扩容数组长度和阈值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过HashMap(int initialCapacity, float loadFactor) 或者 HashMap(int initialCapacity) 【新】创建的HashMap对象</span></span><br><span class="line">    <span class="comment">// 新创建的HashMap对象的阈值threshold的值是通过初始长度initialCapacity生成的一个2的幂。</span></span><br><span class="line">    <span class="comment">// 然后将阈值赋给newCap的目的是保证最终创建的数组长度是2的幂。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 新创建的：直接调用的无参构造函数</span></span><br><span class="line">    <span class="comment">// 数组长度和加载因子/阈值直接使用默认生成的。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对 " else if (oldThr &gt; 0) " 求阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 判断要设置数组长度是否超过了允许的最大容量，来决定阈值的值是现在的值((float)newCap * loadFactor)还是Integer.MAX_VALUE</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 生成一个二倍长度的新数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果是旧数组 =&gt; 直接拷贝元素到新数组</span></span><br><span class="line">    <span class="comment">// 元素在旧数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果只有一个元素（只有一个单链表的头节点或者只有一个红黑树的根节点）</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果不只一个元素，并且元素类型是TreeNode</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 如果不只一个元素，并且是单链表 =&gt; 遍历单链表</span></span><br><span class="line">                <span class="comment">// 保留整个单链表的顺序，然后整体移动到newTab[X ，X如下↓]后面</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 运算结果为0的元素，用loHead记录并连接成新的链表</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 运算结果不为0的元素，用hiHead记录并连接成新的链表</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 参考Q&amp;A</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol><li>JDK8在<code>resize()</code>中，将原先的链表通过<code>if((e.hash &amp; oldCap) == 0)</code>分割成两个子链表，这两个子链表在新数组中的下标为什么是<code>j</code>和<code>j + oldCap</code>？这样在新数组中通过<code>hash &amp; newTab.length - 1</code>能对应上？<ul><li>对于<code>(e.hash &amp; oldCap) == 0</code>的元素(<strong>后面的分析都是基于这个前提</strong>) =&gt; 在原数组中的下标<strong>等于</strong>要转移到新数组中的下标。原因：<ul><li><code>(e.hash &amp; oldCap) == 0?</code>就是判断<code>oldCap</code>高位对应的<code>hash</code>位是否为0。未扩容之前,<code>hash</code>只和<code>oldCap - 1</code><strong>低位</strong>做<code>&amp;</code>运算来求在原始数组中的下标,扩容之后本质上还是和<code>oldCap - 1</code><strong>低位</strong>做<code>&amp;</code>运算来求在新数组中的下标。</li><li>二倍扩容后，新数组的长度<code>newCap</code>为<code>oldCap &lt;&lt; 1</code>，之后求元素在新数组中的下标<code>(hash &amp; (newCap - 1))</code>。因为 <code>newCap - 1</code>高位为0,与此同时高位后一个位(也就是<code>oldCap</code>高位)对应的<code>hash</code>位也为0,所以<code>(hash &amp; (newCap - 1))</code>等价于<code>(hash &amp; (oldCap - 1))</code>。举个例子：  </li></ul></li></ul></li></ol><p>假设<code>oldCap</code>值是<code>2^4 = 16</code>,某个元素e的<code>hash</code>是<code>0111 0101</code>。这个元素在原始数组中的下标应该是<code>hash &amp; oldCap - 1</code> = 5。此时<code>(e.hash &amp; oldCap) == 0</code>,根据结论：如果扩容以后，元素e所在新数组的下标应该还是<code>hash &amp; oldCap - 1</code> = 5。 事实是这样：<code>hash &amp; newCap - 1</code> = 5。</p><table><thead><tr><th align="center">变量</th><th align="center">二进制值</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">oldCap</td><td align="center">0000 1000</td><td align="center">因为是2的幂所以高位为1,低位全为0。</td></tr><tr><td align="center">hash</td><td align="center">0111 0101</td><td align="center">随意选的</td></tr><tr><td align="center">oldCap - 1</td><td align="center">0000 0111</td><td align="center">oldCap - 1的高位为0,低位全为1</td></tr><tr><td align="center">newCap</td><td align="center">0001 0000</td><td align="center">等于<code>2*oldCap</code>，将oldCap左移一位即可</td></tr></tbody></table><p>此时<code>hash &amp; oldCap</code> = 0推出<code>oldCap</code><strong>高位</strong>对应的<code>hash</code>位<strong>一定</strong>为0。否则求出的值绝对不是0。<br>如下图：当通过<code>hash &amp; (newCap - 1)</code>求元素e在新数组中的下标，实际是和最后三位进行<code>&amp;</code>运算，计算结果和<code>hash &amp; (oldCap - 1)</code>一样  </p><table><thead><tr><th align="center">变量</th><th align="center">二进制值</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">hash</td><td align="center">0111 0101</td><td align="center">oldCap高位对应的hash位<strong>为0</strong></td></tr><tr><td align="center">newCap -1</td><td align="center">0000 1111</td><td align="center"></td></tr><tr><td align="center">oldCap - 1</td><td align="center">0000 0111</td><td align="center"></td></tr></tbody></table><ul><li>对于<code>(e.hash &amp; oldCap) != 0</code>的元素(<strong>后面的分析都是基于这个前提</strong>) =&gt; 扩容后元素e在新数组中的下标<strong>等于</strong>元素e在原数组中的下标+原数组长度。 原因：（新数组下标计算过程）<ul><li>新数组下标<ul><li>hash &amp; (newCap - 1)👇</li><li>hash &amp; (2 * oldCap - 1)👇</li><li>hash &amp; (oldCap + oldCap -1)👇</li><li>(hash &amp; oldCap - hash &amp; 1) + hash &amp; oldCap👇<ul><li>由<code>(e.hash &amp; oldCap) != 0</code>可以推出<code>oldCap</code>高位对应的<code>hash</code>位不为0可以推出<code>hash &amp; oldCap == oldCap</code></li></ul></li><li>hash &amp; (oldCap - 1) + oldCap👇</li></ul></li><li>原数组下标 + 原数组长度数组</li></ul></li></ul><table><thead><tr><th align="center">变量</th><th align="center">二进制值</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">hash</td><td align="center">0111 1101</td><td align="center">oldCap高位对应的hash位<strong>不为0</strong></td></tr><tr><td align="center">newCap -1</td><td align="center">0000 1111</td><td align="center"></td></tr><tr><td align="center">oldCap - 1</td><td align="center">0000 0111</td><td align="center"></td></tr></tbody></table><ol start="2"><li><p>为什么长度为6时用链表，为8时用红黑树？中间的7是干嘛的？</p><ul><li>因为红黑树查找时间复杂度为O(LogN)，链表查找时间复杂度为O(N)，当链表中节点数量较多时，为了提高查找效率会采用红黑树。又因为红黑树的节点大约是链表节点的两倍，所以为了节省空间，链表转红黑树的阈值不能太小。</li><li>对于分布均匀的hash函数来说，桶中冲突元素的数量服从泊松分布，冲突元素数量是8的概率为千万分之一，是一个小概率事件，如果这个小概率事件发生了，说明冲突比较严重，这时就会将链表转为红黑树提高查询效率。</li></ul><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  </p></blockquote><ul><li>中间隔一个7为了防止链表和红黑树频繁转换影响效率。如果不隔7的话，元素个数频繁从6变到7或者从8变到7，会造成红黑树和链表频繁的进行转换。(<strong>个人理解</strong>)</li></ul></li><li><p>为什么不是线程安全的?具体体现在哪儿?</p><ul><li><ol><li>在多线程的情况下，并发执行<code>resize()</code>可能会产生环形链表，从而在<code>get()</code>时可能差生inflate loop。</li></ol></li><li><ol start="2"><li>比如并发插入元素时，会并发修改size。</li></ol></li></ul></li><li><p>为什么产生环形链表？</p><ul><li><p>主要是由于转移链表时在新数组中的顺序和原数组顺序不一致导致的。</p><ul><li><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：JAVA HASHMAP的死循环</a></li><li><a href="http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html" target="_blank" rel="noopener">A Beautiful Race Condition(需要科学上网)</a></li></ul></li></ul></li><li><p>为什么求出hashCode()之后要二次hash？</p><ul><li>二次hash为了使得哈希码低位元素更加具有随机性。</li></ul></li><li><p>为什么数组长度是2的幂？</p><ul><li>可以通过位操作<code>&amp;</code>代替<code>%</code>进行取模运算提高效率。</li><li>可以使得求出的数组下标充分依赖hash码，因为2的幂 - 1保证了低位全为1，做&amp;运算可以完全依赖hash，而hash已经通过二次hash随机性很强，从而使得分布会相对均匀。</li></ul></li><li><p>为什么加载因子loadFactor默认是0.75？</p><ul><li>加载因子太大：空间利用率高，查询效率变低，容易发生冲突。  </li><li>加载因子太小：不容易产生冲突，查询效率高，空间利用率低，频繁扩容会产生性能影响  <blockquote><p>As a general rule, <strong>the default load factor (.75) offers a good tradeoff between time and space costs.</strong>  Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in<br>the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations.  If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.  </p></blockquote></li></ul></li><li><p>JDK8和JDK7关于HashMap的区别?  </p><ul><li>JDK7基于数组加链表实现，JDK8引入了红黑树解决了发生hash冲突后，链表过长导致查询效率变低的问题。</li><li>JDK7采用单链表头插法解决hash冲突，JDK8采用尾插法  </li><li>JDK8 resize()后的链表中元素的相对顺序不变。不会产生环形链表（<strong>个人看法，没证明</strong>）</li><li>JDK7数组类型是Entry类型，JDK8改为Node类型都是实现的Map.Entry接口。只是改了个名字</li></ul></li><li><p>HashMap和HashTable的区别？</p><ul><li>HashMap相对于HashTable可以存nul key 和 null value。 HashTable相对于HashMap是线程安全的。<blockquote><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" target="_blank" rel="noopener">The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.</a></p></blockquote></li></ul></li><li><p>为什么key一般用不变对象，比如String、Integer？</p><ul><li>如果对象可变，比如User对象的name属性变了则计算出来的hash会变化，导致求出的数组下标会变从而找不到之前User对应的value。建议key尽量是String或者Integer，不应该是可变的对象。 </li></ul></li><li><p>解决hash冲突的方法？</p></li></ol><ul><li>开放地址法(再散列法)  <ul><li>线性探测：如果冲突了以后，继续向后查找直到找到一个空位</li><li>二次探测：相对于线性探测，它是两步两步的跳着找空位，比较灵活</li></ul></li></ul><blockquote><p>开放地址法适合存放较少数量的键值对，比如<code>Thread</code>中维护的<code>ThreadLocalMap</code>就是用的开放地址法解决的哈希冲突，因为一般通过<code>ThreadLocal</code>设置的键值对数量比较少。如果存放的数量过多，最坏的时间复杂度可能会达到O(n)</p></blockquote><ul><li>链地址法：将冲突的元素，构造成一个单链表</li><li>再哈希法：提前构造多个hash函数，如果某个hash函数冲突以后，再换别的hash函数，直到找到不冲突的为止</li><li>建立公共溢出区：将冲突的元素放到溢出区中，和不冲突的元素分开。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/carson_ho/article/details/79373026" target="_blank" rel="noopener">Java：手把手带你源码分析 HashMap 1.7</a></li><li><a href="https://stackoverflow.com/questions/35534906/java-hashmap-getobject-infinite-loop" target="_blank" rel="noopener">Java HashMap.get(Object) infinite loop</a></li><li><a href="http://blog.jrwang.me/2016/java-collections-hashmap/" target="_blank" rel="noopener">Java 容器源码分析之 HashMap</a></li></ul><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p><code>LinkedHashMap</code>继承自<code>HashMap</code>，在此基础上，将所有<strong>键值对</strong>用双向链表链了起来，这样可以实现元素的迭代顺序和元素的插入顺序一致。在HashMap基础上加了钩子函数，可以实现元素的迭代顺序和元素的访问顺序一致(访问一个元素以后就会将元素放到双链表的尾部)，通过这个特性可以实现LRU cache</p></li><li><p><code>LinkedHashMap</code>不是线程安全的，如果需要线程安全需要使用<code>Collections.synchronizedMap(new LinkedHashMap())</code></p></li><li><p><code>LinkedHashMap</code>继承了<code>HashMap</code>，用到了模板模式。一般的<code>get</code>、<code>put</code>、<code>remove</code>、都用到了<code>HashMap</code>中的操作</p></li></ul><h2 id="部分源码解析"><a href="#部分源码解析" class="headerlink" title="部分源码解析"></a>部分源码解析</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表头指针，在LRU中可以理解为最【老】的节点(如果缓存不够最先剔除的节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表尾指针，在LRU中可以理解为最【新】的节点(如果缓存不够最先剔除的节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是true遍历时按访问顺序，false遍历时按插入顺序。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h3 id="void-afterNodeInsertion-boolean-evict"><a href="#void-afterNodeInsertion-boolean-evict" class="headerlink" title="void afterNodeInsertion(boolean evict)"></a>void afterNodeInsertion(boolean evict)</h3><p>插入元素e后会根据<code>removeEldestEntry(first)</code>这个方法设定的阈值来决定是否要移除最老的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当向map中插入元素后执行的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        <span class="comment">// 执行HashMap中的删除节点api。 first=head就是最老的节点。(看###变量注释👆)</span></span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认直接返回true，可以定制 return size() &gt; 123; 当键值对的数量大于123时就会删除最老的元素。方便实现LRU cache</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-V-get-Object-key"><a href="#public-V-get-Object-key" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h3><p>访问元素e后，如果提前设置了<code>accessOrder</code>为<code>true</code>，就会调用afterNodeAccess(Node&lt;K,V&gt; e)将元素e放到链表的末尾(tail),来实现LRU Cache。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    <span class="comment">// 指向每一个</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 如果设置的访问顺序，也就是accessOrder为true并且链表最后一个节点不是e。就将刚才访问的e这个节点放到最后面</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将节点e的前后节点拼接起来，然后移除e，将e放到链表尾部。</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="comment">// 链表尾指针为空(这是放的第一个元素)，就让head指针指向节点e</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="comment">// 将这个节点放到链表的尾部</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将双向链表尾指针指向e(将e放到双向链表最后面)</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">// 修改次数+1</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="afterNodeRemoval-Node-lt-K-V-gt-e"><a href="#afterNodeRemoval-Node-lt-K-V-gt-e" class="headerlink" title="afterNodeRemoval(Node&lt;K,V&gt; e)"></a>afterNodeRemoval(Node&lt;K,V&gt; e)</h3><p>当执行<code>HashMap</code>中的<code>remove(Object key)</code>删除节点<code>key</code>对应的元素e后，会执行双向链表中删除节点的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// p是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="comment">// p不是头节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// p是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="comment">// p不是尾节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ol><li>实现一个LRU Cache？  <ul><li>设置<code>accessOrder</code>为true，保证最近访问过的元素是最新元素</li><li>重写<code>removeEldestEntry(Map.Entry eldest)</code>设置一个缓存大小</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(CACHE_SIZE,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; lru = <span class="keyword">new</span> LRUCache();</span><br><span class="line">        lru.put(<span class="number">1</span>,<span class="string">"a"</span>);</span><br><span class="line">        lru.put(<span class="number">2</span>,<span class="string">"b"</span>);</span><br><span class="line">        lru.put(<span class="number">3</span>,<span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">// 因为是从双向链表头部开始遍历到尾部，结果应该是 [1,2,3]，</span></span><br><span class="line">        System.out.println(lru.keySet());</span><br><span class="line">        lru.get(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 因为访问了2，所以会将2放到尾部，从双向链表头开始遍历到尾部，结果应该是[1,3,2]</span></span><br><span class="line">        System.out.println(lru.keySet());</span><br><span class="line">        lru.put(<span class="number">4</span>,<span class="string">"d"</span>);</span><br><span class="line">        <span class="comment">// 因为缓存容量设置的是3，所以添加4时 由于缓存已经满了，所以需要删除最老的，就是双向链表头部 1，最后结果应该是[3,2,4]</span></span><br><span class="line">        System.out.println(lru.keySet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="预备知识-1"><a href="#预备知识-1" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Java中的四种引用"><a href="#Java中的四种引用" class="headerlink" title="Java中的四种引用"></a>Java中的四种引用</h3><p>不同的引用类型体现了对垃圾回收的影响，并且可以在一定程度上允许我们<strong>干涉自动垃圾回收器</strong>。在Java中主要有四种引用类型：  </p><h4 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用(StrongReference)"></a>强引用(StrongReference)</h4><p>强引用是通过赋值运算符<code>=</code>将所引用的对象<code>obj</code>关联起来。比如<code>Object obj = new Object()</code>。如果一个对象的强引用还在，该对象就不会被JVM回收。</p><h4 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h4><p>软引用通过<code>SoftReference</code>将所引用的对象<code>obj</code>👆关联起来。比如<code>SoftReference sr = new SoftReference(obj)</code>。在内存不足要发生内存溢出OOM之前，会被JVM回收。</p><ul><li>如果<code>SoftReference</code>注册了引用队列<code>ReferenceQueue</code>，当回收软引用关联的对象<strong>之后</strong>，会将该软引用加入到<code>ReferenceQueue</code>。</li><li>和软引用关联的对象有用但不是必需的，所以软引用可以做缓存。当JVM内存不足时，会将这部分缓存回收掉。比如用户打开了多个图片，就需要加载多个图片内容到内存中，每个图片内容(字节数组)可以和软引用关联当作缓存，如果内存不足时就会清除内存中缓存的图片内容(字节数组)。不过要<strong>注意:</strong>当要再次查看图片时每次都要判断图片内容是否已经被回收(判断引用队列中是否有引用了)，如果被回收需要重新加载到内存。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个Image相当于一个图片，如果打开多个图片等价于创建多个Image对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图片路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">// 通过字节数组存放图片内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="comment">// 要和Image对象关联的软引用</span></span><br><span class="line">    <span class="keyword">private</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference;</span><br><span class="line">    <span class="comment">// 构造图片</span></span><br><span class="line">    Image(String path) &#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="comment">// 将图片加载进来</span></span><br><span class="line">        data = readImageByPath(path);</span><br><span class="line">        softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readImageByPath(String path) &#123;</span><br><span class="line">        <span class="comment">// 为了方便，没有具体实现,一次1MB_</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] dataArray = softReference.get();</span><br><span class="line">        <span class="comment">// 判断data是否已经被回收了，如果被回收了需要重新读取图片内容到内存中</span></span><br><span class="line">        <span class="keyword">if</span> (dataArray == <span class="keyword">null</span> || dataArray.length == <span class="number">0</span>) &#123;</span><br><span class="line">            dataArray = readImageByPath(path);</span><br><span class="line">            softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(dataArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataArray;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同时打开100张图片</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            Image image = <span class="keyword">new</span> Image(i + <span class="string">".jpg"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h4><ul><li>弱引用通过<code>WeakReference</code>将所引用的对象<code>obj</code>关联起来。比如<code>WeakReference sr = new WeakReference(obj)</code>,和弱引用关联的对象在垃圾回收时，会被JVM回收。<ul><li>如果<code>WeakReference</code>注册了引用队列<code>ReferenceQueue</code>，当回收弱引用关联的对象<strong>之后</strong>，会将该弱引用加入到<code>ReferenceQueue</code>。</li><li>和弱引用关联的对象不是必需的，弱引用多用在哈希表中，比如WeakHashMap通过<code>WeakReference</code>可以回收每一个被回收的key对象所关联的Entry(详细见下面源码分析👇)</li></ul></li></ul><blockquote><p>软引用、弱引用基本上没有本质上的区别，仅仅是软引用对象比弱引用对象的命更长一些罢了。<strong>(<a href="https://www.zfl9.com/java-ref.html" target="_blank" rel="noopener">参考链接</a>)</strong><br>因此，软引用、弱引用都适合用来实现内存敏感的高速缓存，具体使用哪种引用，这里给几条参考：<br>1) 如果只是想避免 OutOfMemory 的发生，则可以使用软引用；如果对于性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。<br>2) 如果对象可能会经常使用的，就尽量用软引用；如果对象不被使用的可能性更大些，就可以用弱引用。  </p></blockquote><h4 id="幽灵引用-PhantomReference"><a href="#幽灵引用-PhantomReference" class="headerlink" title="幽灵引用(PhantomReference)"></a>幽灵引用(PhantomReference)</h4><ul><li>幽灵引用通过<code>PhantomReference</code>将所引用的对象<code>obj</code>关联起来。比如<code>PhantomReference sr = new PhantomReference(obj)</code>，和幽灵引用关联的对象等价于没有被引用，随时可能被回收。所以如果不给幽灵引用注册引用队列，那这个幽灵引用就没有意义。<ul><li>如果<code>PhantomReference</code>注册了引用队列<code>ReferenceQueue</code>，当回收幽灵引用关联的对象<strong>之前</strong>(finalize()之后)，会将该幽灵引用放到引用队列中。</li><li>因为每个对象在回收之前，还会执行继承自<code>Object</code>的<code>finalize()</code>用来做一些资源清理的操作，但是JVM什么时间执行<code>finalize()</code>不是确定的。考虑一个场景，在要分配内存创建新的对象时，要确定某个对象要被回收才能分配。此时可以通过幽灵引用结合引用队列实现，当执行了<code>finalize()</code>会将要回收的对象关联的幽灵引用放到引用队列中。此时可以确定这个对象马上要被回收，可以分配内存。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt;(data, queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] get() &#123;</span><br><span class="line">        <span class="comment">// 会阻塞直到队列 非空。非空以后说明已经执行了要被回收的对象的finalize()，可以分配新的内存</span></span><br><span class="line">        queue.remove();  </span><br><span class="line">        <span class="comment">// 幽灵引用不会自动清空，要手动运行 </span></span><br><span class="line">        ref.clear(); </span><br><span class="line">        ref = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 分配内存</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">111</span>];</span><br><span class="line">        <span class="comment">// 重新关联</span></span><br><span class="line">        ref = <span class="keyword">new</span> PhantomReference&lt;<span class="keyword">byte</span>[]&gt;(data, queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p><code>WeakHashMap</code>中的<code>Entry</code>内部的<code>key</code>指向的对象可能会被GC回收，即使没有手动调用<code>remove()</code>或者<code>clear()</code>方法。因为<code>WeakHashMap</code>中的<code>Entry</code>继承自<code>WeakReference</code>，把<code>key</code>引用的对象和弱引用关联起来(<code>Entry</code>继承了<code>WeakReference</code>，也就是将<code>key</code>和<code>Entry</code>关联起来)在JVM进行垃圾回收时会将<code>key</code>引用的对象回收。每次执行<strong>get</strong>、<strong>put</strong>、<strong>resize()</strong>等操作时会根据引用队列提前判断<code>key</code>所引用的对象是否被回收来决定是否清除该<code>key</code>关联的<code>Entry</code>以及<code>Entry</code>中的<code>value</code>指向的对象,来尽量避免内存泄漏。</p><h2 id="部分源码分析-1"><a href="#部分源码分析-1" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h3><p><code>Entry</code>继承了<code>WeakReference</code>，此时<code>Entry</code>也是一个虚引用。每次创建新的<code>Entry</code>时会将key和Entry关联，并且中。当回收了<code>key</code>所引用的对象以后,会将<code>Entry</code>放到引用队列<code>queue</code>中。所以在每次操作时都会从引用队列中取一个<code>Entry</code>释放掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="comment">// 将key和Entry关联，并且给Entry注册一个引用队列queue</span></span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后续没写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-V-get-Object-key-1"><a href="#public-V-get-Object-key-1" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h3><p>根据key获取value，当调用gettable()时会调用expungeStaleEntries()，然后从引用队列中取出Entry,释放掉Entry以及Entry中的value。<br>在WeakHashMap定义的增、删、改、查方法中，都要调用gettable()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果传入的key是null就用Object代替</span></span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    <span class="comment">// 求hash值确定下标</span></span><br><span class="line">    <span class="keyword">int</span> h = hash(k);</span><br><span class="line">    <span class="comment">// 获取原始数组，并且执行getTable()还会调用expungeStaleEntries()</span></span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    <span class="comment">// 获取下标</span></span><br><span class="line">    <span class="keyword">int</span> index = indexFor(h, tab.length);</span><br><span class="line">    <span class="comment">// 找value</span></span><br><span class="line">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// e.get()返回和Entry关联的key</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K,V&gt;[] getTable() &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从引用队列中取出Entry释放掉Entry以及Entry中的value</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从引用队列中取出Entry</span></span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line">            <span class="comment">// 释放Entry(类似删除单链表节点)以及Entry中的value(将e.value=null)</span></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    <span class="comment">// 释放Entry中的value</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    <span class="comment">// 键值对数量减1</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.infoq.cn/article/cf-java-garbage-references" target="_blank" rel="noopener">Java 深度历险（四）——Java 垃圾回收机制与引用类型</a></li><li><a href="https://www.zfl9.com/java-ref.html" target="_blank" rel="noopener">Java 4种引用类型</a></li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/9-WeakHashMap.md" target="_blank" rel="noopener">WeakHashMap</a></li><li><a href="https://crowhawk.github.io/2017/08/29/collection_4/" target="_blank" rel="noopener">Java集合框架源码解读(4)——WeakHashMap</a></li></ul><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p><code>TreeMap</code>是基于红黑树实现的一种<code>Map</code>，对于get、put、remove时间复杂度是log(n)。元素是有序的，顺序是按照key的自然顺序或者是定义的<code>Comparator</code>。</p></li><li><p><code>TreeMap</code>不是线程安全的。如果需要线程安全的<code>TreeMap</code>需要使用<code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p></li><li><p><code>TreeMap</code>实现了<code>NavigableMap</code>间接实现了<code>SortedMap</code>。<strong>注意的是<code>SortedMap</code>比较两个<code>key</code>是否相等不是按<code>Map</code>中规定的<code>equals()</code>，而是用自己定义的<code>Comparator</code>中的<code>compareTo()</code>。</strong> <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">参考Java doc</a>：</p><blockquote><p><strong>This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are,</strong> from the standpoint of the sorted map, equal. The behavior of a sorted map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface.</p></blockquote></li></ul><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><p>因为是通过compareTo()比较两个key是否相等，如果compareTo()写错了会出现TreeMap中明明存在该key，并且equals()返回true，但是get()返回null。如下：(<a href="https://www.liaoxuefeng.com/article/001545657362937e0b6ff640a45422faec234c3f1f23f43000" target="_blank" rel="noopener">下面代码转自廖雪峰大神</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">            Student o = (Student) obj;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, o.name) &amp;&amp; <span class="keyword">this</span>.score == o.score;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score &lt; o.score ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>HashMap</code>测试能正常输出 99 88 77。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Student, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">"Michael"</span>, <span class="number">99</span>), <span class="number">99</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">88</span>), <span class="number">88</span>);</span><br><span class="line">map.put(<span class="keyword">new</span> Student(<span class="string">"Alice"</span>, <span class="number">77</span>), <span class="number">77</span>);</span><br><span class="line">System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Michael"</span>, <span class="number">99</span>)));</span><br><span class="line">System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Bob"</span>, <span class="number">88</span>)));</span><br><span class="line">System.out.println(map.get(<span class="keyword">new</span> Student(<span class="string">"Alice"</span>, <span class="number">77</span>)));</span><br></pre></td></tr></table></figure><p>用<code>TreeMap</code>测试输出 null null null，因为通过hash确定下标后，通过compareTo()返回值是否为0找到key，但是现在compareTo()不会返回0…..，所以会找不到key，然后返回null。<br>重写<code>compareTo()</code>，<strong>保证当<code>key</code>相等时返回0</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integers.compare(<span class="keyword">this</span>.score,o.score);</span><br><span class="line">    <span class="keyword">return</span> result != <span class="number">0</span> ? result : <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">    <span class="comment">//return this.score &lt; o.score ? -1 : 1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="一致性哈希-代码实现思路参照链接"><a href="#一致性哈希-代码实现思路参照链接" class="headerlink" title="一致性哈希 代码实现思路参照链接"></a>一致性哈希 <a href="https://www.cnkirito.moe/consistent-hash-lb/" target="_blank" rel="noopener">代码实现思路参照链接</a></h3><p>实现负载均衡，因为TreeMap提供了获取第一个大于当前节点的API，<code>ceilingEntry()</code></p><ol><li>建环</li><li>构造虚拟节点</li><li>接受请求，根据请求定位<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsitentHash</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚拟节点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个物理服务器中虚拟节点的分隔符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DILEMMA = <span class="string">"-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希策略</span></span><br><span class="line">    <span class="keyword">private</span> HashStrategy hashStrategy = <span class="keyword">new</span> JDKHashCodeStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">select</span><span class="params">(List&lt;Server&gt; servers, Request request)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; hashRing = buildRing(servers);</span><br><span class="line">        <span class="keyword">return</span> locate(request, hashRing);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeMap&lt;Integer, Server&gt; <span class="title">buildRing</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Server&gt; hashRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        servers.forEach(server -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++)</span><br><span class="line">                hashRing.put(hashStrategy.getHashCode(server.getUrl() + DILEMMA + i), server);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> hashRing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">locate</span><span class="params">(Request request, TreeMap&lt;Integer, Server&gt; hashRing)</span> </span>&#123;</span><br><span class="line">        Server server;</span><br><span class="line">        <span class="keyword">int</span> key = hashStrategy.getHashCode(request.getHashKey());</span><br><span class="line">        Map.Entry&lt;Integer, Server&gt; serverEntry = hashRing.ceilingEntry(key);</span><br><span class="line">        <span class="keyword">return</span> serverEntry == <span class="keyword">null</span> ? hashRing.firstEntry().getValue() : serverEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">JDKHashCodeStrategy</span> <span class="keyword">extends</span> <span class="title">HashStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHashCode</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> origin.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String hashKey;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getHashKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hashKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHashKey</span><span class="params">(String hashKey)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hashKey = hashKey;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;java.util.Map&lt;/code&gt;框架：&lt;br&gt;&lt;img src=&quot;/img/in-post/post-java-collection/Map.svg&quot; alt=&quot;Map接口&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JCF" scheme="https://github.jinshuai86.io/tags/JCF/"/>
    
  </entry>
  
  <entry>
    <title>Java容器框架源码阅读笔记（三）Set</title>
    <link href="https://github.jinshuai86.io/2018/07/22/Set/"/>
    <id>https://github.jinshuai86.io/2018/07/22/Set/</id>
    <published>2018-07-21T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.Set</code>框架：<br><img src="/img/in-post/post-java-collection/Set.svg" alt="Set接口框架"></p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><code>Set</code>对<code>Map</code>进行了包裹,利用Map中key的唯一性保证集合中元素的唯一性，所有的key指向同一个对象。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>直接用的<code>HashMap</code>，元素的顺序是不确定的，查找删除等操作的时间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 所有key指向这个对象</span></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是boolean，可以判断是否插入成功，也就是说是否已经存在相应的元素e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>直接用的<code>LinkedHashMap</code>,元素的顺序是确定的，查找删除等操作的时间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>直接用的<code>TreeMap</code>，元素是有序的，查找删除等操作的时间复杂度为O(logn)。元素是有序的，顺序是按照key的自然顺序或者是定义的<code>Comparator</code>。  构建线程安全的TreeSet：<code>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md" target="_blank" rel="noopener">TreeSet and TreeMap</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md#weakhashmap" target="_blank" rel="noopener">CYC2018 Java容器</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;java.util.Set&lt;/code&gt;框架：&lt;br&gt;&lt;img src=&quot;/img/in-post/post-java-collection/Set.svg&quot; alt=&quot;Set接口框架&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;Set&quot;&gt;&lt;a href=&quot;#Set&quot; clas
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JCF" scheme="https://github.jinshuai86.io/tags/JCF/"/>
    
  </entry>
  
  <entry>
    <title>Java容器框架源码阅读笔记（二）Queue、Stack</title>
    <link href="https://github.jinshuai86.io/2018/07/21/Queue&amp;&amp;Stack/"/>
    <id>https://github.jinshuai86.io/2018/07/21/Queue&amp;&amp;Stack/</id>
    <published>2018-07-20T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.Queue</code>和<code>java.util.Stack</code>框架：</p><p><img src="/img/in-post/post-java-collection/Queue.svg" alt="Queue&amp;&amp;Stack"></p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><code>Queue</code>是一个队列接口，继承自<code>Collection</code>。定义了关于FIFO队列的相关操作。</li><li><code>Queue</code>的子接口<code>Deque</code>扩展了<code>Queue</code>。<code>Deque</code>除了继承了FIFO队列的相关操作，<code>Deque</code>还定义了关于双端队列、栈的相关操作。</li><li><code>LinkedList</code>、<code>ArrayDeque</code>通过实现<code>Deque</code>间接实现了<code>Queue</code>。</li><li>在    <code>Queue</code>中定义了三类方法，关于每类方法(增删查)都定义了两种，区别在于出现错误后(比如删除元素/获取队头元素队列已经空了)是抛异常还是返回错误值。对于返回错误值的方法应用场景是队列长度有限制的实现类。  <blockquote><p> Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically<strong>for use with capacity-restricted Queue implementations;</strong> in most implementations, insert operations cannot fail.</p></blockquote></li></ul><table><thead><tr><th align="center">operation</th><th align="center">Throws exception</th><th align="center">Returns special value</th></tr></thead><tbody><tr><td align="center">Insert</td><td align="center">add(e)</td><td align="center">offer(e)</td></tr><tr><td align="center">Remove</td><td align="center">remove()</td><td align="center">poll()</td></tr><tr><td align="center">Examine</td><td align="center">element()</td><td align="center">peek()</td></tr></tbody></table><h2 id="队列操作部分源码分析"><a href="#队列操作部分源码分析" class="headerlink" title="队列操作部分源码分析"></a>队列操作部分源码分析</h2><p>主要翻译<code>ArrayDeque</code>中关于队列操作的具体实现。<br><code>ArrayDeque</code>是通过数组实现了一个循环队列。队列长度可变，当数组元素满了以后，就进行<strong>2倍</strong>扩容。变量<code>head</code>、<code>tail</code>分别表示队头和队尾。<code>head</code>指向队头的元素位置，<code>tail</code>指向队尾元素的下一个位置，也就是下一个要插入的元素应该在的位置。</p><h3 id="public-boolean-add-E-e"><a href="#public-boolean-add-E-e" class="headerlink" title="public boolean add(E e)"></a>public boolean add(E e)</h3><p>添加元素到队尾，通过<code>(tail + 1) &amp; (elements.length - 1)) == head</code>判断队列是否已满(因为队列的长度是2的幂，所以可以通过位运算<code>&amp;</code>来代替<code>%</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 不允许添加null</span></span><br><span class="line"><span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 将元素插入到队尾元素的后面</span></span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="comment">// 判断队列是否已经满了，将队列长度设置为2的幂，可以用位运算代替取模运算</span></span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">    <span class="comment">// 满了以后进行2倍扩容，所以判断队列满和队列空 用head == tail不冲突，因为队列不会满，一旦由于添加元素导致head == tail时，就会进行二倍扩容，保证tail不会因为添加元素【最终】指向head</span></span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-E-element"><a href="#public-E-element" class="headerlink" title="public E element()"></a>public E element()</h3><p>获取队头元素，没有通过<code>head == tail</code>判断队列是否为空，而是通过取得<code>head</code>指针指向的元素是否为空来判断队列是否为空。  </p><p>如果队列为空，<code>element()</code>会抛异常。对应的<code>peek()</code>会返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 获取头指针head指向的队头元素</span></span><br><span class="line">    E result = (E) elements[head];</span><br><span class="line">    <span class="comment">// 如果获取的元素是null，直接抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-E-remove"><a href="#public-E-remove" class="headerlink" title="public E remove()"></a>public E remove()</h3><p>删除队头元素，没有通过<code>head == tail</code>判断队列是否为空，而是通过取得<code>head</code>指针指向的元素是否为空来判断队列是否为空。    </p><p>如果队列为空，<code>remove()</code>会抛异常。对应的<code>poll()</code>会返回null。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = pollFirst();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取head指针</span></span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 获取队头元素</span></span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line">    <span class="comment">// Element is null if deque empty</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将队头变量置空(删除)</span></span><br><span class="line">    elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">    <span class="comment">// 修改head指针</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><code>Stack</code>继承自<code>Vector</code>，是一个LIFO的线性数据结构，只能在栈顶进行操作。通过<code>Vector</code>实现了关于栈的基本操作，当需要使用栈时，Java已不推荐使用<del><code>Stack</code></del>，而是推荐使用更高效的<code>ArrayDeque</code>。  </p><blockquote><p>A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example:<br><code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code></p></blockquote><p><strong>个人观点:</strong> </p><ul><li>原生的<code>Stack</code>是继承是<code>Vector</code>，而<code>Vevtor</code>中的每个方法是加了锁的，所以在效率上可能会降低。不过在JDK6已经对<code>synchronized</code>做了优化，没对比过。    </li><li>栈和队列都是在一端或两端操作，不会直接对中间元素操作(删除，添加)，所以可以避免数组操作中间元素产生较大的时间开销，再就是数组占用的内存在物理上是连续的，所以能更好的用到局部性原理吧。  </li></ul><h2 id="栈操作部分源码分析"><a href="#栈操作部分源码分析" class="headerlink" title="栈操作部分源码分析"></a>栈操作部分源码分析</h2><p>主要翻译<code>ArrayDeque</code>中关于<strong>栈</strong>操作的具体实现。 </p><h3 id="public-void-push-E-e"><a href="#public-void-push-E-e" class="headerlink" title="public void push(E e)"></a>public void push(E e)</h3><p>入栈  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 放在head指向的元素之前，然后栈顶指针往 "前" 循环走</span></span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="comment">// 当head和tail相遇，说明栈满，需要扩容。</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-E-pop"><a href="#public-E-pop" class="headerlink" title="public E pop()"></a>public E pop()</h3><p>出栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = pollFirst();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line">    <span class="comment">// 如果栈是空的，最终获取的元素就是null</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">    <span class="comment">// 栈顶指针往 "后" 循环走</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="FIFO队列和栈的区别？"><a href="#FIFO队列和栈的区别？" class="headerlink" title="FIFO队列和栈的区别？"></a>FIFO队列和栈的区别？</h2><ul><li>队列是一个先进先出(First In First Out)的线性数据结构。可以在队头和队尾进行操作。</li><li>栈是一个后进先出(First In Last Out)的线性数据结构。只能在栈顶进行操作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;java.util.Queue&lt;/code&gt;和&lt;code&gt;java.util.Stack&lt;/code&gt;框架：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/post-java-collection/Queue.svg&quot; alt=&quot;Queue&amp;amp
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JCF" scheme="https://github.jinshuai86.io/tags/JCF/"/>
    
  </entry>
  
  <entry>
    <title>Java容器框架源码阅读笔记（一）List</title>
    <link href="https://github.jinshuai86.io/2018/07/20/List/"/>
    <id>https://github.jinshuai86.io/2018/07/20/List/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.uti.List</code>框架：<br><img src="/img/in-post/post-java-collection/List.svg" alt="List"></p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li>继承自<code>AbstractList</code>。实现了<code>List</code>。实现了<code>RandomAccess</code>标记接口表示可以随机访问。实现了<code>Cloneable</code>标记接口但是是<strong>浅</strong>拷贝。实现了<code>Seriable</code>可以进行序列化。</li><li><code>ArrayList</code>是一个基于数组实现的<strong>可变数组</strong>，数组长度取决于使用的构造函数和传的初始参数，在添加元素过程中可以动态以1.5倍扩容。数组中的元素是有序的，元素可以是null。因此<strong>随机</strong>访问元素的时间复杂度为O(1)，但是插入和删除元素的时间复杂度为O(n)刚好和LinkedList相反(用链表实现的)。</li><li>非线程安全，如果需要线程安全需要使用<code>Vector</code>、<code>Collections.synchronizedList(new ArrayList())</code>、<code>CopyOnWriteArrayList</code></li><li>数组初始容量(<code>DEFAULT_CAPACITY</code>)是10</li></ol><h2 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h2><h3 id="ArrayList-int-initialCapacity"><a href="#ArrayList-int-initialCapacity" class="headerlink" title="ArrayList(int initialCapacity)"></a>ArrayList(int initialCapacity)</h3><p>如果设置的初始容量为0，数组指向长度为0的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList()"></a>ArrayList()</h3><p>如果没有指定数组长度，将默认指向<strong>另一个</strong>(区别于设置的初始长度为0)长度为0的数组。<br>这里和上面形参为0指向的长度为0的数组不一样，目的是可以以此为标识，在<strong>首次</strong>添加元素时，执行不同的的扩容操作。无参构造函数在首次添加元素时，数组会扩容成10(0 -&gt; 10 -&gt; 20)，而形参为0的构造函数在首次添加元素时，只会在0的基础上1.5倍扩容（0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 6）。至于这么做的原因，暂时没想到性能上会带来哪些提升，唯一能想到的就是为了统一？？为了区分不同的构造函数？？TODO。。。 下面是Java Doc：</p><blockquote><p>Shared empty array instance used for default sized empty instances. We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when <strong>first element is added.</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList-Collection-lt-extends-E-gt-c"><a href="#ArrayList-Collection-lt-extends-E-gt-c" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt; c)"></a>ArrayList(Collection&lt;? extends E&gt; c)</h3><p>主要是第二个if，其他两个构造函数逻辑比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将容器c中的元素构造成一个ArrayList，主要看第二个if</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="comment">// 防止继承ArrayList的子类重写toArray返回数组元素类型不是Object，比如是String,当add(1)时候就会抛StoreException异常。</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><p>添加元素，主要涉及了一些扩容的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素：先判断数组容量，然后在添加</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断数组是否已满或者说判断数组是否还有空间</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保数组容量够</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断是否是初次添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否需要扩容</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 如果需要的容量大于当前数组的容量 =&gt; 1.5倍扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将elementData指向一个新的数组</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取旧数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩大1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩容以后还比需要的容量小，则将需要的容量赋值给新容量</span></span><br><span class="line">    <span class="comment">/* 比如使用的是第三个构造函数，传入的c的size为1。</span></span><br><span class="line"><span class="comment">       此时elementData.length = 1;如果调用add，此时传入的minCapacity = size + 1 = 2;</span></span><br><span class="line"><span class="comment">       但是newCapacity = 1 + 1 /2 = 1 &lt; minCapacity，所以有的这个if</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       在或者 使用形参为0的构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果扩容以后大于数组设置的最大容量，如果当前需要的容量小于数组最大容量，就扩展到数组的最大容量，否则就设置为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">// 设置 最大容量的一个目的是：有些虚拟机会在数组中保留一些头部信息，所以可能会造成内存溢出，所以不到万不得已，尽量不超过MAX_ARRAY_SIZE，下面是Java Doc</span></span><br><span class="line">    <span class="comment">// Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 重新拷贝数组</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果minCapacity小于MAX_ARRAY_SIZE就不需要扩容那么大，直接返回MAX_ARRAY_SIZE</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><p>在指定下标添加元素，主要是理解这个函数的使用<code>System.arraycopy(elementData, index, elementData, index + 1, size - index)</code>下同↓</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查下标</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 判断数组容量是否可以在继续放元素，来决定是否进行扩容。</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 从原数组index开始拷贝到从目的数组的index + 1开始的元素。 挨个往后拱 </span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">// 此时index下标的元素已经放到index + 1，将index元素重新赋值即可。</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// 增加数量</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><p>删除指定位置元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 下标检查，防止越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 修改次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取当前下标对应元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 如果删除的是最后一个元素，直接删除，不用移动数组其它元素。</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果删除的不是最后一个元素，需要进行移动。</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 就是将原数组的index + 1 拷贝到原数组的index开始以后的元素。 参数特点是原数组和目的数组一样。</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 方便GC及时回收</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>扩容的反义词：缩容。重新创建一个数组，长度为<code>ArryList</code>中的size。目的是为了防止进行多次remove操作以后，数组长度特别大，但是仅有几个元素导致空间浪费。可以调用此方法重新修剪数组长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="boolean-contains-Object-o"><a href="#boolean-contains-Object-o" class="headerlink" title="boolean contains(Object o)"></a>boolean contains(Object o)</h3><p>是否包含指定元素<code>o</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-indexOf-Object-o"><a href="#int-indexOf-Object-o" class="headerlink" title="int indexOf(Object o)"></a>int indexOf(Object o)</h3><p>找到指定元素<code>o</code>第一次出现的下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从前遍历即可</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-lastIndexOf-Object-o"><a href="#int-lastIndexOf-Object-o" class="headerlink" title="int lastIndexOf(Object o)"></a>int lastIndexOf(Object o)</h3><p>找到指定元素<code>o</code>最后出现的下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从后往前遍历即可</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ol><li>继承自<code>AbstractSequentialList</code>抽象类(只是<strong>非常简单地</strong>实现了<code>List</code>相关方法)  </li><li>实现了<code>List</code>接口、<code>Deque</code>接口(继承自<code>Queue</code>接口，说明<code>LinkedList</code>间接实现了<code>Queue</code>接口)、有关于栈<code>Stack</code>的操作(push、pop)。可以当作一个双向链表、双端队列、FIFO队列、栈。并且可以添加null，这点区别于<code>ArrayDeque</code>。</li><li>非线程安全,如果需要线程安全需要用到<code>List list = Collections.synchronizedList(new LinkedList(...));</code>  </li></ol><h2 id="部分源码分析-翻译"><a href="#部分源码分析-翻译" class="headerlink" title="部分源码分析(翻译:))"></a>部分源码分析(翻译:))</h2><h3 id="public-LinkedList-Collection-lt-extends-E-gt-c"><a href="#public-LinkedList-Collection-lt-extends-E-gt-c" class="headerlink" title="public LinkedList(Collection&lt;? extends E&gt; c)"></a>public LinkedList(Collection&lt;? extends E&gt; c)</h3><p>接收一个<code>Collection</code>类型的变量构造一个<code>LinkedList</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引范围</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 将参数c转化成数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 定义两个指针变量</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">// 链表还没有元素，此时index == 0 &amp;&amp; size == 0;</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    <span class="comment">// 链表已经有元素，在原有基础上又要添加元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-void-clear"><a href="#public-void-clear" class="headerlink" title="public void clear()"></a>public void clear()</h3><p>清除链表中的元素，额外置空操作的意思是将节点之间的链接都断开，虽然不是必须的，但是有助于分代GC    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="实现了队列-Queue-双端队列-Deque-接口"><a href="#实现了队列-Queue-双端队列-Deque-接口" class="headerlink" title="实现了队列(Queue)/双端队列(Deque)接口"></a>实现了队列(Queue)/双端队列(Deque)接口</h3><ul><li>队列接口主要方法<ul><li><code>peek()</code>;<code>element()</code>获取队头元素，如果队列为空，则返回<code>null</code>/则抛异常</li><li><code>offer(E e)</code>队尾入队列</li></ul></li><li>双端队列接口主要方法<ul><li><code>offerFirst(E e);offerLast(E e)</code>从队头/对尾入队列</li><li><code>peekFirst();peekLast()</code>获取队头/队尾元素</li><li><code>pollFirst();pollLast()</code>获取并移除队头/队尾元素 </li></ul></li></ul><h3 id="包含了栈-Stack-操作"><a href="#包含了栈-Stack-操作" class="headerlink" title="包含了栈(Stack)操作"></a><strong>包含了</strong>栈(Stack)<strong>操作</strong></h3><ul><li><code>push(E e)</code> 入栈</li><li><code>pop()</code> 出栈  </li></ul><blockquote><p>JavaDoc建议用<code>ArrayQueue</code>作为<strong>队列</strong>或者<strong>栈</strong>的接口实现,因为它有着比LinkedList更好的性能。 不再建议使用<del><code>Stack stack = new Stack();</code></del>   </p></blockquote><blockquote><p>Resizable-array implementation of the Deque interface. Array deques have no capacity restrictions; they grow as necessary to support usage. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. <strong>This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>LinkedList</code>适合用来做链表/双向链表、双端队列的实现。当用到FIFO队列或者栈时，建议使用<code>ArrayDeque</code>作为实现。比如：<br><code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</code><br><code>Queue&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();</code>   </p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>ArrayList和LinkedList本质区别就是数组和链表的区别</p><h2 id="ArrayList是如何扩容的？"><a href="#ArrayList是如何扩容的？" class="headerlink" title="ArrayList是如何扩容的？"></a>ArrayList是如何扩容的？</h2><ul><li>当添加元素之前需要判断当前数组的容量和需要的容量的差异，当需要的容量大于数组的当前容量，就会重新申请<strong>1.5</strong>倍旧数组大小的新数组，然后将旧数组元素拷贝到新数组。注意的是扩容过程中可能会由于需要的空间大小超出最大值(<code>Integer.MAX_VALUE</code>)而出现OOM。</li></ul><h2 id="ArrayList和LinkedList的区别？"><a href="#ArrayList和LinkedList的区别？" class="headerlink" title="ArrayList和LinkedList的区别？"></a>ArrayList和LinkedList的区别？</h2><ul><li><code>ArrayList</code>用数组实现，数组占据了一段连续的内存空间，支持通过<strong>首地址+偏移量</strong>进行时间复杂度为O(1)的<strong>随机</strong>访问。但是随机插入/删除元素的时间复杂度为O(n)。</li><li><code>LinkedList</code>用链表实现，链表中的每个节点在<strong>物理内存</strong>中并不相邻，所以不支持随机访问。随机插入/删除元素的时间复杂度为O(1)。</li></ul><p>这里要区分一下随机访问和顺序访问，<a href="https://en.wikipedia.org/wiki/Random_access" target="_blank" rel="noopener">维基百科定义</a>：</p><ul><li>随机访问/存取(Random access)<br>In computer science, random access (more precisely and more generally called direct access) is the ability to <strong>access an arbitrary element of a sequence in equal time</strong> or any datum from a population of addressable elements roughly as easily and efficiently as any other, no matter how many elements may be in the set. </li></ul><p>总结就是，访问任意一个元素所用的时间 time(注意是时间，不是时间复杂度)，都是一样的。</p><ul><li>顺序访问(Sequential access)<br>In computer science, sequential access means that a group of elements (such as data in a memory array or a disk file or on magnetic tape data storage) is accessed <strong>in a predetermined, ordered sequence.</strong> </li></ul><p>总结就是，如果要访问一个元素，就需要从前向后依次访问过去，直到目标元素，明显，访问任意一个元素所用时间是不一样的。</p><h2 id="fail-fast机制？"><a href="#fail-fast机制？" class="headerlink" title="fail-fast机制？"></a>fail-fast机制？</h2><p>当使用<code>List</code>的迭代器Iterator的进行操作时，如果<code>List</code>的结构被其它线程修改了(比如添加/删除了一个元素),当前线程在迭代过程中会抛出<code>ConcurrentModificationException</code>。  在生成迭代器的时候会拷贝一份<code>modcount</code>变量到<code>expectedModCount</code>(<code>modcount</code>变量用来记录<code>List</code>被修改的次数)，每次迭代时会判断<code>expectedModCount</code>是否等于<code>modcount</code>变量，如果不相等就说明其它线程对<code>List</code>做了修改,此时会抛出异常而不是继续冒险以一种不确定的行为执行下去。  </p><blockquote><p> <strong>if the list is structurally modified</strong> at any time after the iterator is created, in any way except through the iterator’s own remove or add methods, <strong>the iterator will throw a ConcurrentModificationException.</strong> Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.  </p></blockquote><p><strong>fail-fast机制是用来检测BUG的，不能依赖这个异常来保证程序的正确性。抛出这个异常说明代码写的有问题。</strong></p><blockquote><p>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, <strong>it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.</strong></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://crowhawk.github.io/2017/08/26/collections_1/" target="_blank" rel="noopener">Java集合框架源码解读(1)——ArrayList、LinkedList和Vector</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;java.uti.List&lt;/code&gt;框架：&lt;br&gt;&lt;img src=&quot;/img/in-post/post-java-collection/List.svg&quot; alt=&quot;List&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#Array
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JCF" scheme="https://github.jinshuai86.io/tags/JCF/"/>
    
  </entry>
  
  <entry>
    <title>Java容器框架源码阅读笔记（零）Collection、Map</title>
    <link href="https://github.jinshuai86.io/2018/07/19/Collection/"/>
    <id>https://github.jinshuai86.io/2018/07/19/Collection/</id>
    <published>2018-07-18T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p>Java容器中共有两个接口，分别是<code>Collection</code>和<code>Map</code>。<code>Collection</code>用于存放多个  <strong>“单个对象”</strong>  ，而<code>Map</code>用于存放多个   <strong>“两个对象(键值对)”</strong>  。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p><code>java.uti.Collection</code>框架：<br><img src="/img/in-post/post-java-collection/Collection.svg" alt="Collection接口架构图"></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Collection是</strong>存放单个对象的<strong>容器</strong>。 Collection里<strong>只能存放对象</strong>，不能存放基本类型。对于基本类型(boolean, int, long, float, double)，需要将其包装成对象类型后(Boolean, Integer, Long, Float, Double)才能放到容器里，不过编译器已经帮我们完成了打包和解包的操作。所以可以直接写<code>list.add(1)</code>，而不用<del><code>list.add(Integer.valueOf(1))</code></del></p><h2 id="List"><a href="#List" class="headerlink" title="List"></a><a href="/2018/07/20/List">List</a></h2><ul><li>ArrayList: 基于数组实现的可变数组，非线程安全。</li><li>Vector: 和ArrayList类似，区别是通过synchronized实现了线程安全，但效率较低。</li><li>LinkedList: 双向链表</li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><a href="/2018/07/21/Queue&&Stack">Queue</a></h2><ul><li>LinkedList： 实现了双端队列<code>Deque</code>、FIFO队列<code>Queue</code>。</li><li>ArrayDeque： 基于循环数组实现了双端队列<code>Deque</code>、FIFO队列<code>Queue</code>。<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html" target="_blank" rel="noopener">官方建议使用该类作为<code>Queue</code>和<code>Stack</code>的默认实现。</a></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><a href="/2018/07/22/Set">Set</a></h2><ul><li>HashSet: 基于<code>HashMap</code>实现的集合。元素的遍历顺序和插入顺序<strong>不一致</strong>。</li><li>LinkedHashSet: 基于<code>LinkedHashMap</code>实现的集合。元素的遍历顺序和插入顺序<strong>一致</strong>。</li><li>TreeSet： 基于<code>TreeMap</code>实现的集合。元素有序的，顺序是按照key的自然顺序或者是定义的<code>Comparator</code>。</li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="/2018/07/23/Map">Map</a></h1><p><code>java.uti.Map</code>框架：<br><img src="/img/in-post/post-java-collection/Map.svg" alt="Map接口"></p><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Map是</strong>存放键值对的<strong>容器</strong>。</p><ul><li>HashMap：基于数组、链表、红黑树实现的键值对类型的数据结构，非线程安全。元素的遍历顺序和插入顺序<strong>不一致</strong>。</li><li>HashTable：和<code>HashMap</code>类似，但是线程安全，不过效率较低，不建议使用。建议用<code>ConcurrentHashMap</code>、<code>Collections.synchronizedMap(new HashMap())</code>代替。</li><li>LinkedHashMap：基于<code>HashMap</code>和<code>LinkedList</code>实现的<code>Map</code>。可以实现元素遍历顺序和插入顺序<strong>一致</strong>。也可以实现元素的遍历顺序和访问顺序<strong>一致</strong>。</li><li>TreeMap：基于红黑树实现的<code>Map</code>，元素有序的，顺序是按照key的自然顺序或者是定义的<code>Comparator</code>。</li><li>WeakHashMap：<code>WeakHashMap</code>也是一种<code>Map</code>，其中的<code>Entry</code>可以JVM自动清除释放。其余的操作和HashMap相同，不过没有用到红黑树。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java容器中共有两个接口，分别是&lt;code&gt;Collection&lt;/code&gt;和&lt;code&gt;Map&lt;/code&gt;。&lt;code&gt;Collection&lt;/code&gt;用于存放多个  &lt;strong&gt;“单个对象”&lt;/strong&gt;  ，而&lt;code&gt;Map&lt;/code&gt;用于存放多
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="JCF" scheme="https://github.jinshuai86.io/tags/JCF/"/>
    
  </entry>
  
  <entry>
    <title>synchronized底层实现</title>
    <link href="https://github.jinshuai86.io/2018/07/10/synchronized/"/>
    <id>https://github.jinshuai86.io/2018/07/10/synchronized/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li><p>Java对象（非数组）：用来存储锁，由对象头、实例数据、对齐填充数据组成。<br><img src="/img/in-post/post-java-keyword/object.png" alt="Object"></p><ul><li><p>对象头：由MarkWord、类型指针组成。32位JVM下的Markword占32位，存储的数据取决于锁的状态。</p></li><li><p>初始是无锁状态。<br><img src="/img/in-post/post-java-keyword/noLockState.png" alt="markword">   </p></li><li><p>在运行期间MarkWord里存储的数据会随着锁状态的变化而变化<br><img src="/img/in-post/post-java-keyword/lockState.png" alt="markword"> </p></li></ul></li><li><p>Monitor<strong>类型</strong>对象：重量级锁状态下，MarkWord里的指针指向的对象，ObjectMonitor(C++写的)对Monitor做的实现。</p><ul><li>ObjectMonitor对象<strong>主要</strong>属性：<ul><li>_count用来记录当前线程获取的锁计数</li><li>_WaitSet存放处于wait状态的线程</li><li>_EntryList存放处于等待获取锁，处于block状态的线程队列。</li><li>_owner指向持有ObjectMonitor对象的线程  </li></ul></li></ul></li></ul><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>用来修饰方法（静态方法、实例方法）、代码块</li><li>常说的通过synchronized加锁就是指竞争获取对象头MarkWord重量级锁状态下指向的Monitor类型对象(ObjectMonitor)，但是JDK1.6之后有了优化。</li><li>可以保持原子性(加锁)、保持变量可见性(释放锁会将缓存刷新到主存)、<strong>不防止</strong>指令重排序（比如单例模式DoubleCheck还是会用到volatile防止指令重排序）、</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>JDK1.6之前，在进入synchronized修饰的方法或代码块之前要先获取重量锁（指的是获取对象头指针指向的Monitor类型的对象）<ul><li>当修饰的是静态方法获取的是类的Class对象对应的Monitor对象</li><li>当修饰的是实例方法获取的是该类的实例对象对应的Monitor对象</li><li>当修饰的是代码块需要自己指定</li></ul></li><li>用synchronized修饰的代码块，编译阶段会在方法执行前后生成monitorenter、monitorexit指令。<ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorenter" target="_blank" rel="noopener">JVM规范</a>对于monitorenter指令描述：  <blockquote><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p><ul><li>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</li><li>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</li><li>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</li></ul></blockquote></li><li>每一个对象都有一个Monitor对象，线程通过执行monitorenter指令<strong>尝试</strong>获取Monitor对象的拥有权<ul><li>如果拥有当前Monitor对象的线程数为0，则将_count++,当前线程称为Monitor对象的拥有者。</li><li>如果当前线程已经拥有了此Monitor对象，则将_count++即可。</li><li>如果<strong>其他</strong>线程已经拥有了此Monitor对象，则当前线程阻塞直到Monitor的计数_count==0,然后重新竞争获取锁。</li></ul></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorenter" target="_blank" rel="noopener">JVM规范</a>对于monitorexit指令描述：  <blockquote><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.<br>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so. </p></blockquote></li><li>执行monitorexit指令的线程必须是此Monitor对象的拥有者(否则会抛java.lang.IllegalMonitorStateException异常)，线程减少Monitor对象的锁计数，如果锁计数为0了，则线程不再是Monitor对象的拥有者，其他被这个Monitor对象阻塞的线程可以尝试获取Monitor（之前因没竞争到锁而阻塞的线程需要被执行monitorexit指令的线程唤醒才能重新竞争锁）。</li></ul></li></ul><h2 id="获取重量锁过程"><a href="#获取重量锁过程" class="headerlink" title="获取重量锁过程"></a>获取重量锁过程</h2><ul><li>当线程执行到monitorenter指令，会进入ObjectMonitor对象的_EntryList队列，通过CAS会将_owner指针指向当前线程，同时_count++，</li><li>当前线程执行monitorexit指令，会释放持有的Monitor对象，并将_owner置为null同时_count–</li><li>如果调用wait()，同上，但是会进入_WaitSet队列,等待被唤醒。(wait状态的线程在唤醒之后，需要进入_EntryList<strong>重新获取锁④</strong>，然后执行完毕，退出释放锁)<br><img src="/img/in-post/post-java-keyword/monitor.png" alt="Monitor锁对象状态执行流程"></li></ul><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul><li>原因：因为获取重量级锁过程中，比如将_owner指向当前线程调用的函数涉及到了特权指令Mutex Lock导致用户态和内核态的切换，影响效率(因为线程在用户态和内核态都有<strong>各自</strong>的堆栈、PC、寄存器。当从用户态切换到内核态时需要保存用户态对应的堆栈信息、寄存器、程序计数器的值到内核态的堆栈中，还要通过CPU中的eax ebx ecx等寄存器传递参数到内核态，内核态还要对用户态传入的参数做安全性检查，切换回用户态后还需要恢复用户态现场所以效率会比较低)  </li><li>JDK1.6做了优化，执行monitorenter指令时不会直接获取重量锁，而是先尝试获取偏向锁，=&gt; 轻量锁 =&gt; 重量级锁。</li><li>偏向锁相对于轻量级锁减少了CAS操作的次数，轻量级锁相对于重量级锁减少了系统调用。</li></ul><h2 id="获取偏向锁过程"><a href="#获取偏向锁过程" class="headerlink" title="获取偏向锁过程"></a>获取偏向锁过程</h2><ul><li>原因:大部分情况下不会存在线程竞争，而且只会有<strong>同一个</strong>线程进入临界区，为了减少同一线程获取锁带来的消耗，所以当进入临界区前不会先去获取重量锁，而是先获取偏向锁。</li><li>膨胀成轻量级锁：偏向锁主要是为了解决同一个线程进入临界区，当有超过一个线程竞争偏向锁，就会膨胀为轻量级锁。</li><li>获取偏向锁过程：<ul><li>先判断是否能开启偏向锁，如果可以 =&gt; 将偏向锁偏向线程ID用CAS(相对于轻量级锁获取和释放都需要CAS操作费时，偏向锁只有这一次)修改为当前线程ID。</li></ul></li></ul><h2 id="获取轻量锁过程"><a href="#获取轻量锁过程" class="headerlink" title="获取轻量锁过程"></a>获取轻量锁过程</h2><ul><li>原因:在多个线程都会尝试进入临界区的情况下，多个线程只会<strong>交替</strong>进入临界区，不会存在锁竞争，为了减少重量级锁系统调用造成的消耗。</li><li>膨胀成重量级锁：当多个线程<strong>同一时间</strong>都尝试获取锁，则会膨胀为重量级锁。</li><li>获取轻量级锁获取过程：<ul><li>如果当前无锁并且不可偏向，会尝试获取轻量级锁，将MarkWord拷贝到当前线程的栈帧中的LockRecord，然后通过CAS更新MarkWord内容为指向当前线程LockRecord的指针，</li></ul></li><li>和偏向锁的区别：偏向锁是<strong>同一个</strong>线程多次获取锁，轻量级锁是<strong>多个</strong>线程交替获取锁。相同点是假定都不存在锁竞争。</li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul><li>原因：咳咳,还是大部分情况下，线程持有锁的时间很短，当一个线程获取锁了以后，其他线程尝试获取锁就会进入阻塞状态，挂起-&gt;恢复都需要在用户态和内核态之间进行切换。此时如果让后来的线程进行自旋一段时间(for循环)，在获取锁，可能就会获取，也就避免了转入内核态。</li><li>JDK1.6引入了自适应的自旋锁，即根据具体情况结合前面旋转的次数决定此次需要旋转的次数。</li><li>优点：如果线程占用锁的时间比较短则自旋操作很有效，避免进入内核态</li><li>缺点:如果线程占用锁的时间比较长则自旋操作白白耗费CPU资源，倒不如挂起。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>当修饰方法会在常量池生成ACC_SYNCHRONIZED，当执行某个方法时会如果遇到此指令会同上…</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getClass()) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/in-post/post-java-keyword/byteCode.png" alt="byteCode"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/kundeg/p/8422557.html#_label2" target="_blank" rel="noopener">https://www.cnblogs.com/kundeg/p/8422557.html#_label2</a></li><li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-se-16-synchronized</a></li><li><a href="http://bigdatadecode.club/JavaSynchronizedTheory.html" target="_blank" rel="noopener">http://bigdatadecode.club/JavaSynchronizedTheory.html</a></li><li><a href="http://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">http://www.cnblogs.com/paddix/p/5405678.html</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorenter" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorenter</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java对象（非数组）：用来存储锁，由对象头、实例数据、对齐填充数据组成。&lt;br&gt;&lt;img src=&quot;/i
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://github.jinshuai86.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="JMM" scheme="https://github.jinshuai86.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal应用及原理</title>
    <link href="https://github.jinshuai86.io/2018/07/05/ThreadLocal/"/>
    <id>https://github.jinshuai86.io/2018/07/05/ThreadLocal/</id>
    <published>2018-07-04T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是一个用于创建线程<strong>局部变量</strong>的类。当前线程通过ThreadLocal的set()方法设置的变量<strong>只对当前线程可见</strong>，通过get()获取设置的变量。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li><p>支持泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p>当前线程通过ThreadLocal对象的set(value)/get()设置变量和获取设置的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(<span class="string">"jinshuai"</span>);</span><br><span class="line">threadLocal.get();</span><br></pre></td></tr></table></figure></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul><li>每个线程Thread维护一个ThreadLocalMap&lt;key,value&gt;<ul><li>key是ThreadLocal对象，value是通过set(value)设置的值  </li></ul></li><li>当前线程调用threadLocal.set(“jinshuai”);<ul><li>首先获取当前线程所维护的ThreadLocalMap</li><li>然后判断当前线程是否已经创建过这个ThreadLocalMap<ul><li>如果已经创建，会将ThreadLocal对象当作key，和当前线程要设置的值当作value放到ThreadLocalMap。</li><li>如果没有创建，会创建并初始化一个ThreadLocalMap（类似HashMap 初始化数组长度为2的幂，设置扩充阈值…）然后同上↑</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取线程的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取ThreadLocalMap</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当前线程调用threadLocal.get();<ul><li>首先获取当前线程所维护的ThereadLocalMap</li><li>然后将ThreadLocal对象作为key获取对应的Entry<ul><li>如果Entry不为空获取Entry的value</li><li>如果Entry为空直接返回一个setInitvalue()值也就是null</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将ThreadLocal(this)作为key获取entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">           <span class="comment">// 获取entry的value</span></span><br><span class="line">           T result = (T)e.value;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果entry为空</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>如果一个对象非线程安全，但又不想通过加锁的方式实现线程安全，可以通过ThreadLocal.set()对象的值,比如SimpleDataFormat不是线程安全的，此时可以每个线程设置一个SimpleDataFormat对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> ThreadLocal&lt;&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">formatIt</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> formatter.get().format(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当某一个变量比如User对象在多个方法中传递时，会变得比较乱此时可以通过ThreadLocal设置变量<ul><li>比如在Servlet中： </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doGet(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">    User user = getLoggedInUser(req);</span><br><span class="line">    doSomething(user)</span><br><span class="line">    doSomethingElse(user)</span><br><span class="line">    renderResponse(resp,user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个方法都需要一个user，不够优雅(咳咳…)，此时可以通过设置一个ThreadLocal单例，然后set(user)：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">doGet(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">    User user = getLoggedInUser(req);</span><br><span class="line">    ThreadLocalSingleInstace.getThreadLocal().set(user)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">        doSomethingElse()</span><br><span class="line">        renderResponse(resp)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ThreadLocalSingleInstace.getThreadLocal().remove()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取ThreadLocal单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalSingleInstace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal&lt;User&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocal&lt;User&gt; <span class="title">getThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>用完以后应该调用remove()移除设定的值，防止内存泄漏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会移除这个Entry</span></span><br><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure><ul><li>在线程池中由于线程会被复用，所以<strong>不会停止</strong>，导致每个线程中ThreadLocalMap里的key和虚引用Entry关联(Entry继承了虚引用)，GC时会将key引用的对象回收，但是Entry中的value对象一直有一个强引用value不会被回收造成内存泄漏。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/" target="_blank" rel="noopener">https://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/</a></li><li><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/#" target="_blank" rel="noopener">http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/#</a></li><li><a href="https://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable" target="_blank" rel="noopener">https://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable</a></li><li><a href="https://stackoverflow.com/questions/1490919/purpose-of-threadlocal" target="_blank" rel="noopener">https://stackoverflow.com/questions/1490919/purpose-of-threadlocal</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ThreadLocal是一个用于创建线程&lt;strong&gt;局部变量&lt;/strong&gt;的类。当前线程通过ThreadLocal的set()方法设置的变量&lt;strong&gt;只对当前线程可见&lt;/strong&gt;，通过get()获取设置的变量。&lt;/p&gt;
&lt;h1 id=&quot;使用&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://github.jinshuai86.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>代理</title>
    <link href="https://github.jinshuai86.io/2018/06/26/proxy/"/>
    <id>https://github.jinshuai86.io/2018/06/26/proxy/</id>
    <published>2018-06-25T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li>反射：可以在<strong>运行</strong>期间分析某个类，每个类在JVM方法区都有一个Class对象，用来描述这个类的信息，比如这个类有什么属性，什么方法，修饰符等，通过Class对象可以创建对应类的实例,比如通过newInstance();</li></ul><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><ul><li>为某个对象提供一个代理，以控制对这个对象的访问，好比明星的经纪人是明星的代理，和明星商量事之前可能需要经过他的经纪人。  </li><li>代理可以将一些非业务逻辑代码交由代理对象进行处理，比如记录日志、记录某个操作耗时。  </li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul><li>通过事先写好的代理类的源代码，在<strong>编译</strong>阶段生成相应的字节码文件，即在程序<strong>运行之前</strong>就确定了代理类。</li><li>创建一个类的代理对象可以通过创建该类的子类，然后重写要代理的方法。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">do</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServiceProxy</span> <span class="keyword">extends</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"开始登录"</span>);</span><br><span class="line">            <span class="keyword">super</span>.login();</span><br><span class="line">            log.info(<span class="string">"登录结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LoginService loginService = <span class="keyword">new</span> LoginServiceProxy();</span><br><span class="line">        <span class="comment">// 实现上调用的是代理对象的login();</span></span><br><span class="line">        loginService.login();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果被代理类实现了接口，还可以通过创建一个实现了被代理类实现的接口的代理类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ILoginService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginService</span> <span class="keyword">implements</span> <span class="title">ILoginService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理对象类，提前写好</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServiceProxy</span> <span class="keyword">implements</span> <span class="title">ILoginService</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要有被代理对象的引用</span></span><br><span class="line">        LoginService loginService;</span><br><span class="line"></span><br><span class="line">        Proxy(LoginService loginService) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loginService = loginService;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"开始登录"</span>);</span><br><span class="line">            loginService.<span class="keyword">do</span>();</span><br><span class="line">            log.info(<span class="string">"登录结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILoginService loginService = <span class="keyword">new</span> LoginServiceProxy();</span><br><span class="line">        <span class="comment">// 实现上调用的是代理对象的login();</span></span><br><span class="line">        loginService.login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：将非业务代码抽取出来，减少耦合性。</li><li>缺点：如果被代理的方法数量较多的话，工作量会较大。</li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>在编译阶段不会生成字节码文件，在<strong>运行</strong>期间通过反射创建代理对象。</li><li>在Java里有JDK动态代理或者CGLIB动态代理两种实现。</li></ul><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><ul><li>在<strong>运行期间</strong>，Proxy会生成目标类的代理类的字节码，通过类加载器加载进虚拟机，最终通过反射来创建代理类的实例。代理类默认继承了Proxy，并且实现了目标类实现的接口。</li><li>要求<ul><li>被代理对象所属的类需要实现接口</li><li>创建一个处理器InvocationHandler用于集中处理方法调用</li></ul></li><li>被代理对象和代理对象是兄弟关系</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理对象，需要实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理对象    </span></span><br><span class="line">    Object target;</span><br><span class="line">    </span><br><span class="line">    Handler(Object target) &#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object Proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建处理器，并传入被代理对象</span></span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Target());</span><br><span class="line">        <span class="comment">// Proxy通过反射创建代理对象</span></span><br><span class="line">        <span class="comment">// 代理对象是实现了目标对象的接口的一个对象，所以强制转换成目标对象（Target），就会报错，应该转换成它们共同的接口(ITarget)</span></span><br><span class="line">        ITarget proxyInstance = (ITarget) Proxy.newProxyInstance(Target.class.getClassLoader(),</span><br><span class="line">                Target.class.getInterfaces(),handler);</span><br><span class="line">        <span class="comment">// 实际调用的代理对象的sayHello();</span></span><br><span class="line">        proxyInstance.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CLGLIB动态代理"><a href="#CLGLIB动态代理" class="headerlink" title="CLGLIB动态代理"></a>CLGLIB动态代理</h3><ul><li>在运行期间通过ASM解析目标类的字节码，进行修改（为了生成被代理对象的子对象），形成新的字节数组，重新通过类加载器ClassLoader加载到虚拟机中，通过反射创建代理对象，此代理对象是被代理对象的子对象。</li><li>要求<ul><li>被代理对象不能用final修饰，因为需要创建被代理对象的子对象作为代理对象</li></ul></li><li>被代理对象和代理对象之间是父子关系 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个增强器，用来在运行时生成类</span></span><br><span class="line">Enhancer ch = <span class="keyword">new</span> Enhancer();</span><br><span class="line"><span class="comment">// 设置要继承的目标类</span></span><br><span class="line">eh.setSuperclass(Target.class);</span><br><span class="line"><span class="comment">// 设置拦截器，通过回调实现，类似JDK动态代理里的InvocationHandler处理器</span></span><br><span class="line">eh.setCallback(<span class="keyword">new</span> XXXInterceptor());</span><br><span class="line"><span class="comment">// 生成新的代理类</span></span><br><span class="line">Target target = (Target)eh.create();</span><br><span class="line"><span class="comment">// 调用代理类的方法</span></span><br><span class="line">target.function();</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s/cTJ_IankiFOdwZZLq3mHQA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cTJ_IankiFOdwZZLq3mHQA</a></li><li><a href="https://mp.weixin.qq.com/s/D_W8zTz38dKQBq3Tzm42Xg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/D_W8zTz38dKQBq3Tzm42Xg</a></li><li><a href="https://mp.weixin.qq.com/s/ax288tkY1YIClmEl5Dg1Hg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ax288tkY1YIClmEl5Dg1Hg</a></li><li><a href="http://layznet.iteye.com/blog/1182924" target="_blank" rel="noopener">http://layznet.iteye.com/blog/1182924</a></li><li><a href="https://www.jianshu.com/p/23d3f1a2b3c7" target="_blank" rel="noopener">https://www.jianshu.com/p/23d3f1a2b3c7</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;反射：可以在&lt;strong&gt;运行&lt;/strong&gt;期间分析某个类，每个类在JVM方法区都有一个Class对象，用
      
    
    </summary>
    
      <category term="设计模式" scheme="https://github.jinshuai86.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>volatile底层实现</title>
    <link href="https://github.jinshuai86.io/2018/06/25/volatile/"/>
    <id>https://github.jinshuai86.io/2018/06/25/volatile/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li>可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li><li>重排序：如果在单线程下对于指令的重排不会影响逻辑，那么在可以提高运行效率的前提下会进行适当的指令重排。</li><li>缓存行：CPU中的缓存是分段的，一段对应一个存储空间，称为缓存行，缓存行是CPU缓存中可分配的最小存储单元。</li><li>CPU缓存：为了解决CPU运算速度和内存读取速度不一致问题，CPU加入了缓存机制（L1、L2、L3），CPU通过系统总线、IO桥、内存总线从主内存中读取数据到CPU缓存中，此后将会从缓存中读取数据，进行运算然后刷新缓存。如果是单核CPU没什么问题，但在多核CPU下，各个核对自己缓存中的数据进行修改，但其它核并不知道，会造成各个核中的缓存不一致。</li><li>嗅探技术：每个核都可以”嗅探”到其它核缓存中共享变量的状态(MESI)、以及对缓存和主存的读写操作。</li><li>缓存一致性协议<ul><li>实现一：BusLocking（总线锁）:通过对总线进行加锁。当一个核对其缓存中的变量进行操作时就会对总线发一个Lock#信号，其它核收到该信号（嗅探技术）就不会继续操作自己缓存中的该变量，当操作结束释放锁以后其它核就会重新从主内存中读取该变量到缓存中。 缺点：总线锁会降低性能。</li><li>实现二：MESI：通过在缓存行上设置状态标志位。在MESI协议中，每个核缓存对应的缓存控制器不仅知道自己的读写操作，而且<strong>也监听(snoop)其它核对其缓存的读写操作，并根据其操作修改自己缓存标志位。</strong></li></ul></li></ul><table><thead><tr><th align="center">当前状态</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">M</td><td align="center">当前核缓存的变量与主内存不一致</td></tr><tr><td align="center">E</td><td align="center">缓存的变量只存在当前核</td></tr><tr><td align="center">S</td><td align="center">各个核中缓存的变量处于一致状态</td></tr><tr><td align="center">I</td><td align="center">当前核中缓存的变量无效</td></tr></tbody></table><ul><li>举个例子：当核1中缓存的变量状态从S变为M，同时核2通过嗅探技术，嗅探到此操作，然后会使其缓存行标志位变为I，当核2再读取对应数据时，会判断其它核中缓存的此数据的标志位，发现核1的缓存行标志位是M，则会触发将核1中的缓存行刷新到主内存中，然后核2从主内存中读取到缓存中。</li><li>Lock汇编指令：<ul><li>将当前核中的对缓存的修改刷新到主内存中<ul><li>会锁定当前缓存，将当前缓存中的数据回写到主存中。并通过缓存一致性协议保证操作是原子操作。</li></ul></li><li>使其它核中的缓存无效<ul><li>回写到主存中的操作会<strong>导致其它核中缓存的失效</strong></li></ul></li><li>此指令相当于一个内存屏障，保证不会将此指令之前的操作和此指令之后的操作和此指令进行重新排序。</li></ul></li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>volatile用来修饰变量，使得变量具有可见性。同时保证对此变量的操作指令不会发生重排序</li><li>对于volatile变量的操作没有相关的加锁操作，性能会比synchronized要高。</li><li><strong>不</strong>保证原子性</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>可见性<ul><li>对于volatile变量的<strong>写</strong>操作会生成lock汇编指令，导致将缓存回写到主存中，并且使其它线程的工作内存(对应到CPU核的缓存)的此变量失效(就是MESI协议里的Invalid状态)<ul><li>比如在线程A，线程B工作内存中缓存着主内存中的变量a（对应底层的cpu核缓存的状态就是a的状态为S)当线程A将工作内存中a = 1，此时线程B中的a失效，当线程B再次读取a的时候需要从主内存中重新读取。</li></ul></li></ul></li><li>有序性<ul><li>执行lock汇编指令时会保证它之前的操作已经执行完毕，并且对其后的操作可见，即只有执行完了lock指令才会执行后续的操作。</li></ul></li><li>不保证原子性<ul><li>反证：假如核1，核2都将共享变量a（初始为0）读到缓存进行修改，核1将a++，核2将a += 3，此时核1将缓存中的a修改为1，导致核2缓存里的a变为Invalid。当核2回写缓存a = 3的时候，发现a所在缓存行状态是Invalid，导致核2需要从主存中读 a = 1，此时会触发核1的缓存中的a = 1刷新到主存中，<strong>然后核2从内存中读取a = 1并修改自己的缓存中的a = 1</strong>，并没有和预期的a最终变为4相符，即不保证原子性。 后续就是核1的对a的缓存状态变为I，核2变为M</li></ul></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>不与其它状态变量共同参与不变约束(比如volatile int a;while(a &gt; b) 而b就是其它状态变量)</li><li>对此变量的写操作不依赖与当前值(比如a = 1就是不依赖当前值，a = a + 1就依赖了当前值)</li></ul><h2 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h2><ul><li>作为状态变量,因为它的可见性保证当它修改以后 其他线程可以及时看到。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!shutdown) &#123;</span><br><span class="line">            <span class="comment">// doSomething();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        shutdown = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉式单例模式双重检测（Double Check）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Main obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Main <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                      new 操作会执行三个操作  </span></span><br><span class="line"><span class="comment">                      1. 分配内存  </span></span><br><span class="line"><span class="comment">                      2. 初始化内存  </span></span><br><span class="line"><span class="comment">                      3. 将引用执行内存，返回引用  </span></span><br><span class="line"><span class="comment">                      但2. 3. 可能重排序，导致没有初始化内存就将引用变量obj返回，此时并不是预期的Main对象。  </span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    obj = <span class="keyword">new</span> Main();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不严格的读写锁策略<blockquote><p>读的时候并没有排斥写，适用更新不频繁的情况。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可见性保证最新的 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接加锁保证对依赖当前值的操作具有原子性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile#anch134390" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/ftf-java-volatile#anch134390</a></li><li><a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/MESI_protocol</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a></li><li><a href="https://crowhawk.github.io/2018/02/10/volatile/" target="_blank" rel="noopener">https://crowhawk.github.io/2018/02/10/volatile/</a></li><li><a href="https://www.cnblogs.com/xrq730/p/7048693.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/7048693.html</a></li><li><a href="https://read.douban.com/ebook/15233695/" target="_blank" rel="noopener">https://read.douban.com/ebook/15233695/</a></li><li><a href="http://www.ixirong.com/2015/08/22/java-volatile/" target="_blank" rel="noopener">http://www.ixirong.com/2015/08/22/java-volatile/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。&lt;/li&gt;
&lt;li&gt;重排序：如果在单线程下
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://github.jinshuai86.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="JMM" scheme="https://github.jinshuai86.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>停止一个线程</title>
    <link href="https://github.jinshuai86.io/2018/06/22/StopThread/"/>
    <id>https://github.jinshuai86.io/2018/06/22/StopThread/</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2022-06-11T10:26:46.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><ul><li>interrupt() Thread的非静态方法，标记当前线程的中断状态为true;</li><li>isInterrupted() Thread的非静态方法，查看当前线程的中断状态;</li><li>interrupted() Thread的静态方法，查看当前线程的中断状态，并清除(将状态改为false)；</li><li>如果当前线程设置了中断，然后调用sleep()/wait()/join()或者当前线程处于sleep()/wait()/join()然后中断该线程会抛出InterruptException，并且会清除中断状态。</li><li>volatile 修饰变量，使得被修饰的变量修改以后引起其他线程工作内存中对此变量的缓存无效，进而保持可见性。</li></ul><h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><h2 id="通过轮询线程的中断状态"><a href="#通过轮询线程的中断状态" class="headerlink" title="通过轮询线程的中断状态"></a>通过轮询线程的中断状态</h2><ul><li>通过设置中断状态，进而通过轮询中断状态决定是否停止。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 轮询中断状态</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果在while里面使用了sleep()/wait()/join(),此时如果通过设置线程中断状态停止线程，会抛出InterruptException，会清除中断状态，导致不会正常停止，所以需要重新设置线程中断状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            doFirstPartOfIncrement();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 抛出了InterruptException，此时会清除当前线程的中断状态，需要重新设置中断状态，保证线程正常终止</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过轮询共享变量"><a href="#通过轮询共享变量" class="headerlink" title="通过轮询共享变量"></a>通过轮询共享变量</h2><ul><li>通过设置共享变量，进而通过轮询共享变量决定是否停止。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 轮询状态变量</span></span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过Thread-stop"><a href="#通过Thread-stop" class="headerlink" title="通过Thread.stop()"></a>通过Thread.stop()</h2><ul><li>JDK已经标记为@Deprecated<blockquote><p>This method is inherently unsafe.  Stopping a thread with Thread.stop causes it to unlock all of the monitors that it has locked (as a natural consequence of the unchecked ThreadDeath exception propagating up the stack).  If any of the objects previously protected by these monitors were in an inconsistent state, the damaged objects become visible to other threads, potentially resulting in arbitrary behavior.</p></blockquote></li><li>会将此线程获取的Monitor对象（也就是常说的通过synchronized获取的锁）释放。比如一个线程负责维护一个对象Product中的两个变量saleCount和StockCount处于saleCount &lt;= stockCount状态，当某个时刻saleCount &gt; stockCount,同时此线程被stop()强制停止，会导致逻辑错误。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/" target="_blank" rel="noopener">http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/</a></li><li><a href="https://stackoverflow.com/questions/3194545/how-to-stop-a-java-thread-gracefully" target="_blank" rel="noopener">https://stackoverflow.com/questions/3194545/how-to-stop-a-java-thread-gracefully</a></li><li><a href="https://stackoverflow.com/questions/10630737/how-to-stop-a-thread-created-by-implementing-runnable-interface" target="_blank" rel="noopener">https://stackoverflow.com/questions/10630737/how-to-stop-a-thread-created-by-implementing-runnable-interface</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;interrupt() Thread的非静态方法，标记当前线程的中断状态为true;&lt;/li&gt;
&lt;li&gt;isIn
      
    
    </summary>
    
      <category term="Java" scheme="https://github.jinshuai86.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.jinshuai86.io/tags/Java/"/>
    
  </entry>
  
</feed>
